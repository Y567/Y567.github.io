<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>K-NN算法实现（鸢尾花数据）</title>
    <url>/python/K-NN%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%88%E9%B8%A2%E5%B0%BE%E8%8A%B1%E6%95%B0%E6%8D%AE%EF%BC%89/</url>
    <content><![CDATA[<h1 id="运行环境-Jupyter"><a href="#运行环境-Jupyter" class="headerlink" title="运行环境:Jupyter"></a>运行环境:Jupyter</h1><h1 id="一、K-近邻算法"><a href="#一、K-近邻算法" class="headerlink" title="一、K-近邻算法"></a>一、K-近邻算法</h1><p>K-近邻（K-NN）算法可以说是最简单的机器算法。构建模型只需要保存训练数据集即可。想要对新数据点做出预测，算法会在训练数据集中找到最近的数据点，也就是它的“最近邻”。</p>
<p> 这里实现的是一个监督学习中的分类（二分类）问题。我们需要预测出测试数据的所属类别。</p>
<a id="more"></a>
<h1 id="二、实现步骤"><a href="#二、实现步骤" class="headerlink" title="二、实现步骤"></a>二、实现步骤</h1><h2 id="1-获取数据集"><a href="#1-获取数据集" class="headerlink" title="1.获取数据集"></a>1.获取数据集</h2><p>   导入Numpy方便操作数据，pyplot用来绘图<br><img data-src="https://img-blog.csdnimg.cn/20191011175411368.png" alt="在这里插入图片描述"><br>解释：<br>(1)load_iris()：导入鸢尾花数据<br>(2)x_data = datas[‘data’][0:150]，y_data= datas[‘target’][0:150]：<br>利用切片操作获取数据集。‘data’对应的就是鸢尾花的数据。target对应的是类别。</p>
<p>最终的源数据集为：<br>x_data(150组源数据)：<br><img data-src="https://img-blog.csdnimg.cn/20191011175505538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDE5NDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>……一共150组数据<br>y_data(代表类别):<br><img data-src="https://img-blog.csdnimg.cn/20191011175556976.png" alt="在这里插入图片描述"><br>也是150组数据。</p>
<h2 id="2-将数据集分为训练集和测试集"><a href="#2-将数据集分为训练集和测试集" class="headerlink" title="2.将数据集分为训练集和测试集"></a>2.将数据集分为训练集和测试集</h2><p>训练集获取：<br>   <img data-src="https://img-blog.csdnimg.cn/20191011175622824.png" alt="在这里插入图片描述"><br>解释：利用切片操作将源数据的一半作为训练集。从0开始到150，左闭右开，步长为2。获取75组数据。</p>
<p>测试集数据获取：<br><img data-src="https://img-blog.csdnimg.cn/20191011175651555.png" alt="在这里插入图片描述"><br>解释：利用切片操作将源数据的一半作为训练集。从1开始到150，左闭右开，步长为2。获取75组数据。</p>
<h1 id="3-构建模型"><a href="#3-构建模型" class="headerlink" title="3.构建模型"></a>3.构建模型</h1><p>1.绘制散点图：<br><img data-src="https://img-blog.csdnimg.cn/20191011175725349.png" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20191011175736771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDE5NDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>注意：这里的横纵坐标分别对应鸢尾花的花萼的长和宽，由于四维向量不能绘制，所以取前两个元素作为说明。</strong><br>2.k-NN的过程：<br><img data-src="https://img-blog.csdnimg.cn/20191011175820440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDE5NDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20191011175831953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDE5NDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>解释：黑色的点表示需要预测的数据，我们需要求出离它最近的几个点的类别，利用投票法决定黑色点的类别，由图可知黑色点最后的类别应该和绿色点一样为0</p>
<p>具体算法：（求距离就是求两坐标点间的距离）     <img data-src="https://img-blog.csdnimg.cn/20191011175910637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDE5NDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20191011175948760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDE5NDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>最后结果预测是0和绿色点的类别相同至此构建模型结束。</p>
<h2 id="4-用测试集的数据测试求出精度"><a href="#4-用测试集的数据测试求出精度" class="headerlink" title="4.用测试集的数据测试求出精度"></a>4.用测试集的数据测试求出精度</h2><p> <img data-src="https://img-blog.csdnimg.cn/20191011180027335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDE5NDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>解释：这里其实就是对测试集数据重复之前的操作，然后将测试集数据的预测结果和其正确的类别进行比较，记录预测正确的个数，最后除以总共测试的数据就求出了此模型的精度。<br><img data-src="https://img-blog.csdnimg.cn/20191011180049123.png" alt="在这里插入图片描述"></p>
<h1 id="三、算法实现"><a href="#三、算法实现" class="headerlink" title="三、算法实现"></a>三、算法实现</h1><p>?<strong>代码是顺序的</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#加载鸢尾花数据</span></span><br><span class="line">datas = load_iris()</span><br><span class="line"><span class="comment">#利用切片收集150组鸢尾花数据(datas['data']表示datas的‘data’key值对应的数据，即鸢尾花的花瓣花萼数据)</span></span><br><span class="line">x_data = datas[<span class="string">'data'</span>][<span class="number">0</span>:<span class="number">150</span>]</span><br><span class="line"><span class="comment">#表示鸢尾花源数据的类别，0代表setosa,1代表versicolor,2代表virginica（K-NN算法处理基于监督学习的分类问题）</span></span><br><span class="line"><span class="comment">#datas['target']表示datas的‘target’key值对应的数据，即鸢尾花的类别（标签）</span></span><br><span class="line">y_data = datas[<span class="string">'target'</span>][<span class="number">0</span>:<span class="number">150</span>]</span><br><span class="line"><span class="comment">#产生训练集（鸢尾花源数据的百分之50）</span></span><br><span class="line">x_train = x_data[<span class="number">0</span>:<span class="number">150</span>:<span class="number">2</span>]</span><br><span class="line">y_train = y_data[<span class="number">0</span>:<span class="number">150</span>:<span class="number">2</span>]</span><br><span class="line"><span class="comment">#产生测试集（鸢尾花源数据的百分之50）</span></span><br><span class="line">x_test = x_data[<span class="number">1</span>:<span class="number">150</span>:<span class="number">2</span>]</span><br><span class="line">y_test = y_data[<span class="number">1</span>:<span class="number">150</span>:<span class="number">2</span>]</span><br><span class="line">y_data</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#绘制训练集（这里只以鸢尾花数据的前两个作为坐标绘制借来说明算法的原理，因为四维的不能绘制）</span></span><br><span class="line">plt.scatter(x_train[y_train==<span class="number">0</span>,<span class="number">0</span>],x_train[y_train==<span class="number">0</span>,<span class="number">1</span>],color=<span class="string">'g'</span>,label=<span class="string">"symbol 0"</span>)</span><br><span class="line">plt.scatter(x_train[y_train==<span class="number">1</span>,<span class="number">0</span>],x_train[y_train==<span class="number">1</span>,<span class="number">1</span>],color=<span class="string">'r'</span>,label=<span class="string">"symbol 1"</span>)</span><br><span class="line">plt.scatter(x_train[y_train==<span class="number">2</span>,<span class="number">0</span>],x_train[y_train==<span class="number">2</span>,<span class="number">1</span>],color=<span class="string">'b'</span>,label=<span class="string">"symbol 2"</span>)</span><br><span class="line">plt.title(<span class="string">"k-NN view"</span>)</span><br><span class="line">plt.xlabel(<span class="string">"x axis"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"y axis"</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#新增加一个数据(该数据是示例)判断其的类别为0 or 1 or 2（根据距离）</span></span><br><span class="line">x = np.array([<span class="number">4.5023242</span>,<span class="number">3.03123123</span>,<span class="number">1.3023123</span>,<span class="number">0.102123123</span>])</span><br><span class="line">plt.scatter(x_train[y_train==<span class="number">0</span>,<span class="number">0</span>],x_train[y_train==<span class="number">0</span>,<span class="number">1</span>],color=<span class="string">'g'</span>,label=<span class="string">"symbol 0"</span>)</span><br><span class="line">plt.scatter(x_train[y_train==<span class="number">1</span>,<span class="number">0</span>],x_train[y_train==<span class="number">1</span>,<span class="number">1</span>],color=<span class="string">'r'</span>,label=<span class="string">"symbol 1"</span>)</span><br><span class="line">plt.scatter(x_train[y_train==<span class="number">2</span>,<span class="number">0</span>],x_train[y_train==<span class="number">2</span>,<span class="number">1</span>],color=<span class="string">'b'</span>,label=<span class="string">"symbol 2"</span>)</span><br><span class="line">plt.scatter(x[<span class="number">0</span>],x[<span class="number">1</span>],color=<span class="string">'black'</span>,label=<span class="string">"symbol ?"</span>)</span><br><span class="line">plt.title(<span class="string">"k-NN view"</span>)</span><br><span class="line">plt.xlabel(<span class="string">"x axis"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"y axis"</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#K-NN过程（计算距离，并将其存储到列表）</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line">distances = []</span><br><span class="line"><span class="keyword">for</span> x0 <span class="keyword">in</span> x_train:</span><br><span class="line">    d = sqrt(np.sum((x-x0)**<span class="number">2</span>))</span><br><span class="line">    distances.append(d)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将距离排序（由大到小）返回的是元素下标</span></span><br><span class="line">near = np.argsort(distances)</span><br><span class="line">k = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#选择出前5个最近元素的类别</span></span><br><span class="line">topK_y = [y_train[i] <span class="keyword">for</span> i <span class="keyword">in</span> near[:k]]</span><br><span class="line">topK_y</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="comment">#统计元素出现的个数(即代表这鸢尾花类别的数字的个数)</span></span><br><span class="line">votes = Counter(topK_y)</span><br><span class="line">votes</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#找出票数最多的一个元素，该方法返回的是一个元组，我们只需要key值（也就是类别）</span></span><br><span class="line"><span class="comment">#出预测的结果，0代表setosa,1代表versicolor,2代表virginica</span></span><br><span class="line">result = votes.most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">result</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#注意这里用的是上面的数据，但是步骤是重新开始的因为要一个个遍历测试集并将预测结果与源数据中的结果比较得出正确率</span></span><br><span class="line"><span class="comment">#统计测试数据的精度</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> x_test:</span><br><span class="line">    distance = []</span><br><span class="line">    x = j;</span><br><span class="line">    <span class="comment">#计算距离</span></span><br><span class="line">    <span class="keyword">for</span> x1 <span class="keyword">in</span> x_train:</span><br><span class="line">        t = sqrt(np.sum((x-x1)**<span class="number">2</span>))</span><br><span class="line">        distance.append(t)</span><br><span class="line">    near = np.argsort(distance)</span><br><span class="line">    topK_y = [y_train[i] <span class="keyword">for</span> i <span class="keyword">in</span> near[:k]]</span><br><span class="line">    votes = Counter(topK_y)</span><br><span class="line">    result = votes.most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> y_test[index]==result:</span><br><span class="line">        count=count+<span class="number">1</span></span><br><span class="line">        index=index+<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        index=index+<span class="number">1</span></span><br><span class="line">score=count/<span class="number">75</span></span><br><span class="line">score</span><br></pre></td></tr></table></figure>


<p>若代码有误请参考：<a href="https://blog.csdn.net/qq_42419462/article/details/102507657" target="_blank" rel="noopener">代码</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>求最大公约数不同算法比较</title>
    <url>/C/%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E4%B8%8D%E5%90%8C%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p><strong>后附完整源代码：（含有求最大公倍数的函数，此代码测试的是面对不同组数据，各种算法的性能分析，如需输出最大公约数，只需加个输出就好！）</strong></p>
<h2 id="一、-题目分析"><a href="#一、-题目分析" class="headerlink" title="一、 题目分析"></a>一、 题目分析</h2><p>首先，题目要求我们求出俩个正整数的最大公约数和最小公倍数，并提供了6种不同的算法（递归与非递归算俩种）<br><strong>1.    辗转相除法</strong>：此种方法核心如其名，辗转，大数放a中，小数放b中。大的除以小的，余数为零，则小数为最大公约数，不为零则，将余数与b比较大的放a,小的放b,如此往复！<br><strong>2.    穷举法</strong>：看到这个穷举就知道它是最吃力不讨好的算法了。一个个穷举不仅浪费CPU,还浪费时间对吧，对两个正整数a,b如果能在区间[a,0]或[b,0]内能找到一个整数temp能同时被a和b所整除，则temp即为最大公约数。<br><strong>3.    更相减损术</strong>：</p>
<a id="more"></a>
<p>第一步：任意给定两个正整数；判断它们是否都是偶数。若是，则用2约简；若不是则执行第二步。<br>第二步：以较大的数减较小的数，接着把所得的差与较小的数比较，并以大数减小数。继续这个操作，直到所得的减数和差相等为止。<br>则第一步中约掉的若干个2与第二步中等数的乘积就是所求的最大公约数。<br>其中所说的“等数”，就是最大公约数。求“等数”的办法是“更相减损”法。所以更相减损法也叫等值算法！<br><strong>4.    Stein算法</strong>：<br>通过数学的思想进行验证出：对于俩个俩个正整数数（x&gt;y）：<br>均为偶数gcd(x,y)=2gcd(x/2,y/2)；<br>均为奇数gcd(x,y)=gcd((x+y)/2,(x-y)/2)；<br>x奇y偶gcd(x,y)=gcd(x,y/2)；<br>x偶y奇gcd(x,y) =gcd(x/2,y)或gcd(x,y)=gcd(y,x/2)；<br>也就是说可以对俩奇俩偶和一奇一偶的情况进行化简，使其更容易计算。<br>又因为该算法采用位移运算所以减少了很多时间，所以也是很厉害的算法。<br><strong>我们的主要目的是为了比较各个算法的性能优劣，通过程序的运行，输出不同算法计算20,40,80…200组甚至更大的数据的计算时间。</strong></p>
<h2 id="二、-算法构造"><a href="#二、-算法构造" class="headerlink" title="二、 算法构造"></a>二、 算法构造</h2><p>可爱的狗狗走错片场：<br><img data-src="https://img-blog.csdnimg.cn/20190307170051533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDE5NDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>①    辗转相除法（非递归）：<br>算法流程图：<br><img data-src="https://img-blog.csdnimg.cn/20190307164347842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDE5NDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>②    辗转相除法（非递归）：<br>算法盒图：<br><img data-src="https://img-blog.csdnimg.cn/20190307164537364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDE5NDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>③    辗转相除法（递归）：<br><img data-src="https://img-blog.csdnimg.cn/20190307164552464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDE5NDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>④    辗转相除法（递归盒图）：<br><img data-src="https://img-blog.csdnimg.cn/20190307164654883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDE5NDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>⑤    穷举法流程图：<br><img data-src="https://img-blog.csdnimg.cn/2019030716475858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDE5NDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>⑥    穷举法（盒图）：<br><img data-src="https://img-blog.csdnimg.cn/20190307164808837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDE5NDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>⑦    更相减损术（流程图）：<br><img data-src="https://img-blog.csdnimg.cn/201903071648265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDE5NDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>⑧    更相减损术（盒图）：<br><img data-src="https://img-blog.csdnimg.cn/20190307164855244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDE5NDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>⑨    Stein算法（流程图）：<br> <img data-src="https://img-blog.csdnimg.cn/20190307164909644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDE5NDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>⑩    Stein算法（递归盒图）：<br> <img data-src="https://img-blog.csdnimg.cn/20190307164920370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDE5NDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="三、-算法实现"><a href="#三、-算法实现" class="headerlink" title="三、 算法实现"></a>三、 算法实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">class Math</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	int temp;</span><br><span class="line">public:</span><br><span class="line">	int divistor(int,int); &#x2F;&#x2F;NO.1，辗转相除法</span><br><span class="line">	int multiple(int,int);</span><br><span class="line"></span><br><span class="line">    int digui(int,int);    &#x2F;&#x2F;NO.2，辗转相除法递归</span><br><span class="line">	int multiple1(int,int);</span><br><span class="line"></span><br><span class="line">	int divistor3(int,int);&#x2F;&#x2F;NO.3，穷举法</span><br><span class="line">	int multiple3(int,int);</span><br><span class="line"></span><br><span class="line">    int divistor4(int,int);&#x2F;&#x2F;NO.4，更相减损术</span><br><span class="line">	int multiple4(int,int);</span><br><span class="line"></span><br><span class="line">    int gcd(int,int);     &#x2F;&#x2F;NO.5,stein算法递归算法</span><br><span class="line">	int multiple5(int,int);&#x2F;&#x2F;求最大公倍数</span><br><span class="line"></span><br><span class="line">    int gcd1(int,int);     &#x2F;&#x2F;NO.6,stein算法非递归算法</span><br><span class="line">	int multiple6(int,int);&#x2F;&#x2F;求最大公倍数</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int Math::divistor(int x,int y)&#x2F;&#x2F;x是大数，y是小数,非递归实现   NO.1</span><br><span class="line">&#123;</span><br><span class="line">	if(x&lt;y)</span><br><span class="line">	&#123;</span><br><span class="line">		temp&#x3D;x;</span><br><span class="line">		x&#x3D;y;</span><br><span class="line">		y&#x3D;temp;</span><br><span class="line">	&#125;</span><br><span class="line">	while(y!&#x3D;0)       &#x2F;&#x2F;当y是0时，最大公约数就是x;</span><br><span class="line">	&#123;</span><br><span class="line">		temp&#x3D;x%y;</span><br><span class="line">		x&#x3D;y;          &#x2F;&#x2F;这3句不能交换位置，否则temp值会出错</span><br><span class="line">		y&#x3D;temp;</span><br><span class="line">	&#125;</span><br><span class="line">	return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Math::multiple(int x,int y)  &#x2F;&#x2F;求最大公倍数</span><br><span class="line">&#123;</span><br><span class="line">	temp&#x3D;divistor(x,y);&#x2F;&#x2F;</span><br><span class="line">	return ((x*y)&#x2F;temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int Math::digui(int x,int y)&#x2F;&#x2F;无需区别x,y的大小，递归方法</span><br><span class="line">&#123;</span><br><span class="line">	if(x%y&#x3D;&#x3D;0)</span><br><span class="line">		return y;</span><br><span class="line">	else</span><br><span class="line">		return digui(y,x%y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Math::multiple1(int x,int y)  &#x2F;&#x2F;求最大公倍数</span><br><span class="line">&#123;</span><br><span class="line">	temp&#x3D;digui(x,y);</span><br><span class="line">	return ((x*y)&#x2F;temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int Math::divistor3(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">	temp&#x3D;(x&gt;y)?y:x;</span><br><span class="line">    while(temp&gt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		if(x%temp&#x3D;&#x3D;0&amp;&amp;y%temp&#x3D;&#x3D;0)</span><br><span class="line">			break;</span><br><span class="line">		else temp--;</span><br><span class="line">	&#125;</span><br><span class="line">		return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Math::multiple3(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">	int p,q;</span><br><span class="line">	p&#x3D;x&gt;y?x:y;&#x2F;&#x2F;xiaozhi</span><br><span class="line">	q&#x3D;x&gt;y?y:x;&#x2F;&#x2F;dazhi</span><br><span class="line">	temp&#x3D;p;</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		if(p%q&#x3D;&#x3D;0)</span><br><span class="line">			break;</span><br><span class="line">		else</span><br><span class="line">			p+&#x3D;temp;</span><br><span class="line">	&#125;</span><br><span class="line">	return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int Math::divistor4(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">	int i&#x3D;0;</span><br><span class="line">	int z&#x3D;1;</span><br><span class="line">	while(x%2&#x3D;&#x3D;0 &amp;&amp; y%2&#x3D;&#x3D;0)  &#x2F;&#x2F;判断m和n能被多少个2整除</span><br><span class="line">	&#123;</span><br><span class="line">		x&#x2F;&#x3D;2;</span><br><span class="line">		y&#x2F;&#x3D;2;</span><br><span class="line">		i+&#x3D;1;</span><br><span class="line">	&#125;</span><br><span class="line">	if(x&lt;y)     &#x2F;&#x2F;x是大数</span><br><span class="line">	&#123;</span><br><span class="line">		temp&#x3D;x;</span><br><span class="line">		x&#x3D;y;</span><br><span class="line">		y&#x3D;temp;</span><br><span class="line">	&#125;</span><br><span class="line">	while(z)</span><br><span class="line">	&#123;</span><br><span class="line">		z&#x3D;x-y;</span><br><span class="line">		x&#x3D;(y&gt;z)?y:z;</span><br><span class="line">		y&#x3D;(y&lt;z)?y:z;</span><br><span class="line">		if(y&#x3D;&#x3D;x)</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">	if(i&#x3D;&#x3D;0)</span><br><span class="line">		return y;</span><br><span class="line">	else </span><br><span class="line">		return (int )pow(2,i)*y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Math::multiple4(int x,int y)  &#x2F;&#x2F;求最大公倍数</span><br><span class="line">&#123;</span><br><span class="line">	temp&#x3D;divistor4(x,y);</span><br><span class="line">	return ((x*y)&#x2F;temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int Math::gcd(int x,int y)     &#x2F;&#x2F;stein算法递归算法</span><br><span class="line">&#123;</span><br><span class="line">	if(x&lt;y)     &#x2F;&#x2F;x是大数</span><br><span class="line">	&#123;</span><br><span class="line">		temp&#x3D;x;</span><br><span class="line">		x&#x3D;y;</span><br><span class="line">		y&#x3D;temp;</span><br><span class="line">	&#125;</span><br><span class="line">	if(y&#x3D;&#x3D;0) return x;</span><br><span class="line">	if((x&amp;0x1)&#x3D;&#x3D;0&amp;&amp;(y&amp;0x1)&#x3D;&#x3D;0) return 2*gcd(x&gt;&gt;1,y&gt;&gt;1); &#x2F;&#x2F;俩数都是偶数</span><br><span class="line">	if((x&amp;0x1)&#x3D;&#x3D;0&amp;&amp;(y&amp;0x1)!&#x3D;0) return gcd(x&gt;&gt;1,y);     &#x2F;&#x2F;一偶一奇</span><br><span class="line">    if((x&amp;0x1)!&#x3D;0&amp;&amp;(y&amp;0x1)&#x3D;&#x3D;0) return gcd(x,y&gt;&gt;1);     &#x2F;&#x2F;一奇一偶</span><br><span class="line">	if((x&amp;0x1)!&#x3D;0&amp;&amp;(y&amp;0x1)!&#x3D;0) return gcd((x-y)&gt;&gt;1,y); &#x2F;&#x2F;俩奇</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Math::multiple5(int x,int y)  &#x2F;&#x2F;求最大公倍数</span><br><span class="line">&#123;</span><br><span class="line">	temp&#x3D;gcd(x,y);</span><br><span class="line">	return ((x*y)&#x2F;temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Math::gcd1(int a,int b)        &#x2F;&#x2F;stein算法非递归</span><br><span class="line">&#123;</span><br><span class="line">    int acc&#x3D;0;</span><br><span class="line">    while((a&amp;0x1)&#x3D;&#x3D;0&amp;&amp;(b&amp;0x1)&#x3D;&#x3D;0)</span><br><span class="line">	&#123;</span><br><span class="line">        ++acc;</span><br><span class="line">        a&gt;&gt;&#x3D;1;</span><br><span class="line">        b&gt;&gt;&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    while((a&amp;0x1)&#x3D;&#x3D;0) a&gt;&gt;&#x3D;1;</span><br><span class="line">    while((b&amp;0x1)&#x3D;&#x3D;0) b&gt;&gt;&#x3D;1;</span><br><span class="line">    if(a&lt;b) &#123;int t&#x3D;a; a&#x3D;b; b&#x3D;t;&#125;</span><br><span class="line">    while((a&#x3D;(a-b)&gt;&gt;1)!&#x3D;0)</span><br><span class="line">	&#123;</span><br><span class="line">        while((a&amp;0x1)&#x3D;&#x3D;0) a&gt;&gt;&#x3D;1;</span><br><span class="line">        if (a&lt;b) &#123;int t&#x3D;a; a&#x3D;b; b&#x3D;t;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return b&lt;&lt;acc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Math::multiple6(int x,int y)  &#x2F;&#x2F;求最大公倍数</span><br><span class="line">&#123;</span><br><span class="line">	temp&#x3D;gcd1(x,y);</span><br><span class="line">	return ((x*y)&#x2F;temp);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int x,y,i,t;                  &#x2F;&#x2F;t为数组的元素个数</span><br><span class="line">	char c[20];                   &#x2F;&#x2F;用于判断整数的正确性</span><br><span class="line">	Math m;                       &#x2F;&#x2F;创建对象m</span><br><span class="line">	double z;                </span><br><span class="line">	LARGE_INTEGER nFreq;          &#x2F;&#x2F;时间</span><br><span class="line">	LARGE_INTEGER nBeginTime;</span><br><span class="line">	LARGE_INTEGER nEndTime;</span><br><span class="line">	QueryPerformanceFrequency(&amp;nFreq);</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;&quot;请输入小于10000的测试组数(正整数：一组俩个数):&quot;&lt;&lt;endl;</span><br><span class="line">	cin.getline(c,7);                &#x2F;&#x2F;7为函数读取的制定字符</span><br><span class="line">	if((c[0]-48)&lt;&#x3D;0||(c[0]-48)&gt;9) &#123;cout&lt;&lt;&quot;输入的不是正整数，请重新输入！&quot;; return 0;&#125;</span><br><span class="line">	for(i&#x3D;1;i&lt;20;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(c[i]&#x3D;&#x3D;&#39;\0&#39;) break;</span><br><span class="line">		if((c[i]-48)&lt;0||(c[0]-48)&gt;9) &#123;cout&lt;&lt;&quot;输入的不是正整数，请重新输入！&quot;; return 0;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	i&#x3D;atoi(c);</span><br><span class="line">	if(i&lt;0||i&gt;10000) &#123;cout&lt;&lt;&quot;输入数超出范围，请重新输入!&quot;; return 0;&#125;</span><br><span class="line">	int a[20000];</span><br><span class="line">    t&#x3D;2*i;</span><br><span class="line">	srand((unsigned)time(NULL));  &#x2F;&#x2F;产生随机数种子，避免产生的随机数相同</span><br><span class="line">	for(i&#x3D;0;i&lt;t;i++)              &#x2F;&#x2F;初始化数组</span><br><span class="line">	&#123;</span><br><span class="line">		a[i]&#x3D;rand();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    QueryPerformanceCounter(&amp;nBeginTime);&#x2F;&#x2F;开始计时</span><br><span class="line">	for(i&#x3D;0;i&lt;t;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		x&#x3D;a[i];</span><br><span class="line">		y&#x3D;a[i+1];</span><br><span class="line">		i+&#x3D;1;                     &#x2F;&#x2F;让x,y正好取得数组中的元素，如果没有i+&#x3D;1会出错</span><br><span class="line">     	m.divistor(x,y);</span><br><span class="line">	    &#x2F;&#x2F;m.multiple(x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	QueryPerformanceCounter(&amp;nEndTime);&#x2F;&#x2F;结束计时</span><br><span class="line">	z&#x3D;(double)(nEndTime.QuadPart-nBeginTime.QuadPart)&#x2F;(double)nFreq.QuadPart;&#x2F;&#x2F;计算程序执行时间单位为s</span><br><span class="line">	cout&lt;&lt;&quot;辗转相除法非递归所用时长：&quot;&lt;&lt;z*1000&lt;&lt;&quot;毫秒&quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	QueryPerformanceCounter(&amp;nBeginTime);&#x2F;&#x2F;开始计时</span><br><span class="line">	for(i&#x3D;0;i&lt;t;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		x&#x3D;a[i];</span><br><span class="line">		y&#x3D;a[i+1];</span><br><span class="line">		i+&#x3D;1;                     &#x2F;&#x2F;让x,y正好取得数组中的元素，如果没有i+&#x3D;1会出错</span><br><span class="line">     	m.digui(x,y);</span><br><span class="line">	    &#x2F;&#x2F;m.multiple1(x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	QueryPerformanceCounter(&amp;nEndTime);&#x2F;&#x2F;结束计时</span><br><span class="line">	z&#x3D;(double)(nEndTime.QuadPart-nBeginTime.QuadPart)&#x2F;(double)nFreq.QuadPart;&#x2F;&#x2F;计算程序执行时间单位为s</span><br><span class="line">	cout&lt;&lt;&quot;辗转相除法递归所用时长：&quot;&lt;&lt;z*1000&lt;&lt;&quot;毫秒&quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	QueryPerformanceCounter(&amp;nBeginTime);&#x2F;&#x2F;开始计时</span><br><span class="line">	for(i&#x3D;0;i&lt;t;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		x&#x3D;a[i];</span><br><span class="line">		y&#x3D;a[i+1];</span><br><span class="line">		i+&#x3D;1;                     &#x2F;&#x2F;让x,y正好取得数组中的元素，如果没有i+&#x3D;1会出错</span><br><span class="line">     	m.divistor3(x,y);</span><br><span class="line">	    &#x2F;&#x2F;m.multiple3(x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	QueryPerformanceCounter(&amp;nEndTime);&#x2F;&#x2F;结束计时</span><br><span class="line">	z&#x3D;(double)(nEndTime.QuadPart-nBeginTime.QuadPart)&#x2F;(double)nFreq.QuadPart;&#x2F;&#x2F;计算程序执行时间单位为s</span><br><span class="line">	cout&lt;&lt;&quot;穷举法所用时长：&quot;&lt;&lt;z*1000&lt;&lt;&quot;毫秒&quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	QueryPerformanceCounter(&amp;nBeginTime);&#x2F;&#x2F;开始计时</span><br><span class="line">	for(i&#x3D;0;i&lt;t;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		x&#x3D;a[i];</span><br><span class="line">		y&#x3D;a[i+1];</span><br><span class="line">		i+&#x3D;1;                     &#x2F;&#x2F;让x,y正好取得数组中的元素，如果没有i+&#x3D;1会出错</span><br><span class="line">     	m.divistor4(x,y);</span><br><span class="line">	    &#x2F;&#x2F;m.multiple4(x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	QueryPerformanceCounter(&amp;nEndTime);&#x2F;&#x2F;结束计时</span><br><span class="line">	z&#x3D;(double)(nEndTime.QuadPart-nBeginTime.QuadPart)&#x2F;(double)nFreq.QuadPart;&#x2F;&#x2F;计算程序执行时间单位为s</span><br><span class="line">	cout&lt;&lt;&quot;更相减损术法所用时长：&quot;&lt;&lt;z*1000&lt;&lt;&quot;毫秒&quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	QueryPerformanceCounter(&amp;nBeginTime);&#x2F;&#x2F;开始计时</span><br><span class="line">	for(i&#x3D;0;i&lt;t;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		x&#x3D;a[i];</span><br><span class="line">		y&#x3D;a[i+1];</span><br><span class="line">		i+&#x3D;1;                     &#x2F;&#x2F;让x,y正好取得数组中的元素，如果没有i+&#x3D;1会出错</span><br><span class="line">     	m.gcd(x,y);</span><br><span class="line">	    &#x2F;&#x2F;m.multiple5(x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	QueryPerformanceCounter(&amp;nEndTime);&#x2F;&#x2F;结束计时</span><br><span class="line">	z&#x3D;(double)(nEndTime.QuadPart-nBeginTime.QuadPart)&#x2F;(double)nFreq.QuadPart;&#x2F;&#x2F;计算程序执行时间单位为s</span><br><span class="line">	cout&lt;&lt;&quot;stein算法非递归所用时长：&quot;&lt;&lt;z*1000&lt;&lt;&quot;毫秒&quot;&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	QueryPerformanceCounter(&amp;nBeginTime);&#x2F;&#x2F;开始计时</span><br><span class="line">	for(i&#x3D;0;i&lt;t;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		x&#x3D;a[i];</span><br><span class="line">		y&#x3D;a[i+1];</span><br><span class="line">		i+&#x3D;1;                     &#x2F;&#x2F;让x,y正好取得数组中的元素，如果没有i+&#x3D;1会出错</span><br><span class="line">     	m.gcd1(x,y);</span><br><span class="line">	    &#x2F;&#x2F;m.multiple6(x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	QueryPerformanceCounter(&amp;nEndTime);&#x2F;&#x2F;结束计时</span><br><span class="line">	z&#x3D;(double)(nEndTime.QuadPart-nBeginTime.QuadPart)&#x2F;(double)nFreq.QuadPart;&#x2F;&#x2F;计算程序执行时间单位为s</span><br><span class="line">	cout&lt;&lt;&quot;stein算法递归所用时长：&quot;&lt;&lt;z*1000&lt;&lt;&quot;毫秒&quot;&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、运行结果："><a href="#四、运行结果：" class="headerlink" title="四、运行结果："></a>四、运行结果：</h2><p>③结果<img data-src="https://img-blog.csdnimg.cn/20190307165535474.png" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20190307165525871.png" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/20190307165556808.png" alt="在这里插入图片描述"><br>通过不同组数据的测试我们发现：<br>当数据小的时候：辗转相除法，更相减损术，stein算法，都比较用时少。<br>只有穷举法用时最长。（此时区别还不明显！）<br>但数据变大的时候：stein递归算法的好处就显现出来，次之的就是辗转相除法（非递归）了。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>这次的上机报告真的收获了许多，比较算法我也在上学期做过，比较不同排序的算法性能，当时用的是clock()函数，因为测试的数据比较庞大，有30000组数据，所以clock()函数已经足够显现出算法的区别。但是这次的程序，让我学到了一个新的测试时间的函数，它更精确，区别更明显！<br>高精度时控函数QueryPerformanceFrequency（），QueryPerformanceCounter（）<br>原理：<br>QueryPerformanceCounter()这个函数返回高精确度性能计数器的值,它可以以微妙为单位计时.但是QueryPerformanceCounter()确切的精确计时的最小单位是与系统有关的,所以,必须要查询系统得到QueryPerformanceCounter()返回的嘀哒声的频率. QueryPerformanceFrequency()提供了这个频率值,返回每秒嘀哒声的个数. 计算确切的时间是从第一次调用QueryPerformanceCounter()开始的 假设得到的LARGE_INTEGER为nStartCounter,过一段时间后再次调用该函数结的, 设得到nStopCounter. 两者之差除以QueryPerformanceFrequency()的频率就是开始到结束之间的秒数.由于计时函数本身要耗费很少的时间,要减去一个很少的时间开销.但一般都把这个开销忽略。<br>还有对字符串有了更深一步的理解，cin,cin.getline(),cin.get()函数的区别！<br><strong>cin.get()函数与cin.getline()函数区别：<br>cin.getline()：在遇到回车符时，结束字符串输入并丢弃回车符。<br>cin.get()：在遇到回车符时，则会保留回车符在输入队列。</strong></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>单词小助手</title>
    <url>/C%E8%AF%AD%E8%A8%80/%E5%8D%95%E8%AF%8D%E5%B0%8F%E5%8A%A9%E6%89%8B/</url>
    <content><![CDATA[<p>/<strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong>/<br>名称：单词小助手（稍微改善版）<br>编程语言：C<br>编译器：DEV C++<br>完成日期：2019年04月03日</p>
<p><strong>PS:此程序不是本人制作，我只是在源程序上进行添加功能和进行改善</strong></p>
<p>添加功能如下：<br>（1）排行榜功能<br>（2）数据验证<br>（3）错词重记忆<br>单词小助手：<br>首先题目已经给出了基本的代码，也实现了基本的功能，比如说添加单词，修改，删除，查询，以及单词小测试等功能，我们需要做的就是改善其中的功能，更进一步添加新的功能，比如说改善其中的数据验证，添加排行功能，错词重复记忆！让单词小助手更激发用户的攀比！<br>增加了一点小小的颜色：界面换了个颜色之类的。</p>
<a id="more"></a>
<p>界面截图：<br>1.主界面：<br><img data-src="https://img-blog.csdnimg.cn/2019040320193480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDE5NDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2.词库维护：<br><img data-src="https://img-blog.csdnimg.cn/20190403201943553.png" alt="在这里插入图片描述"><br>3.单词预览：<br><img data-src="https://img-blog.csdnimg.cn/20190403201952326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDE5NDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.单词背诵：<br><img data-src="https://img-blog.csdnimg.cn/20190403201957954.png" alt="在这里插入图片描述"><br><img data-src="https://img-blog.csdnimg.cn/2019040320200340.png" alt="在这里插入图片描述"><br>5.查询成绩：<br><img data-src="https://img-blog.csdnimg.cn/20190403202011195.png" alt="在这里插入图片描述"><br>6.帮助：<br><img data-src="https://img-blog.csdnimg.cn/20190403202017883.png" alt="在这里插入图片描述"><br>7.排行榜：<br><img data-src="https://img-blog.csdnimg.cn/2019040320202621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDE5NDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="PS-非原创"><a href="#PS-非原创" class="headerlink" title="PS:非原创"></a><strong>PS:非原创</strong></h2><p>不废话了，直接bia源代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_CHAR  20  <span class="comment">// 最大字符</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NUM  200  <span class="comment">// 单词的最大个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_U 20       <span class="comment">//用户人数 </span></span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">word</span></span></span><br><span class="line"><span class="class">//单词的结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  en[MAX_CHAR]; <span class="comment">// 英文形式</span></span><br><span class="line">   <span class="keyword">char</span>  ch[MAX_CHAR];   <span class="comment">//中文形式</span></span><br><span class="line">&#125;  s[MAX_NUM]; <span class="comment">//单词数组</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">rankinglist</span></span></span><br><span class="line"><span class="class">//用户名单结构体 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> user[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> c,d;       <span class="comment">//c为单词错误数，d为单词正确数 </span></span><br><span class="line">	<span class="keyword">int</span> core;     <span class="comment">//成绩 </span></span><br><span class="line">&#125;r[MAX_U];         </span><br><span class="line"><span class="keyword">int</span>   num;           <span class="comment">//单词个数</span></span><br><span class="line"><span class="keyword">int</span>   num1=<span class="number">0</span>;          <span class="comment">//用户数 </span></span><br><span class="line"><span class="keyword">int</span> select=<span class="number">1</span>;<span class="comment">//select 为是否退出系统的标记</span></span><br><span class="line"><span class="keyword">int</span> d=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> core;    <span class="comment">//成绩 </span></span><br><span class="line"><span class="comment">//帮助</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n本系统主要实现英语单词学习的功能。用户可对词典文件中的单词进行预览，增删改查。"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n同时还可进行中译英、英译中测试。本系统还提供了测试成绩的显示功能。"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n经过改善本系统添加了新的排行榜功能期待你来挑战第一名！另：还有错词循环记忆让你记忆不愁。"</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查数据选项</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">panduan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> c[<span class="number">50</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,c); </span><br><span class="line">    <span class="keyword">if</span>(c[<span class="number">1</span>]==<span class="string">'\0'</span>)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(c[<span class="number">0</span>]&gt;=<span class="string">'0'</span>&amp;&amp;c[<span class="number">0</span>]&lt;=<span class="string">'9'</span>)</span><br><span class="line">    	<span class="keyword">return</span> c[<span class="number">0</span>]-<span class="string">'0'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//数据验证（英文）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">panduan1</span><span class="params">(<span class="keyword">char</span> a[])</span></span>&#123;     <span class="comment">//返回0不是英文单词，返回1是 </span></span><br><span class="line">	<span class="keyword">int</span> i;  </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;      <span class="comment">//判断条件是i不是a[i]啊啊啊 </span></span><br><span class="line">		<span class="keyword">if</span>(a[i]&gt;=<span class="string">'a'</span>&amp;&amp;a[i]&lt;=<span class="string">'z'</span>||a[i]==<span class="string">'\0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"亲，这边建议您输入英文呢！"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;      </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从文件中读取单词的信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">readfile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   FILE *fp;</span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   fp=fopen(<span class="string">"data.txt"</span>,<span class="string">"r"</span>);   <span class="comment">//“r”方式打开不允许改写文件 </span></span><br><span class="line">   <span class="keyword">if</span>(!fp)                     <span class="comment">//说明没有文件 </span></span><br><span class="line">   &#123;</span><br><span class="line">	   <span class="built_in">printf</span>(<span class="string">"\n打开文件data.txt失败!"</span>);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span>(<span class="built_in">fscanf</span>(fp,<span class="string">"%s %s "</span>,s[i].en,s[i].ch)==<span class="number">2</span>)  <span class="comment">//以空格符，换行符等为结束标志，返回值为实际读取的字符串个数 </span></span><br><span class="line">   &#123;              </span><br><span class="line">	   i++;                                       <span class="comment">//读取下一个单词 </span></span><br><span class="line">   &#125;</span><br><span class="line">   num=i;</span><br><span class="line">   <span class="keyword">if</span>(<span class="number">0</span>==i)            </span><br><span class="line">	   <span class="built_in">printf</span>(<span class="string">"\n文件为空，请选择词典维护增加词条！"</span>);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">	   <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">   fclose(fp);                                    <span class="comment">//读取完毕，关闭文件 </span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从文件中写入单词的信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">writefile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   FILE *fp;</span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   fp=fopen(<span class="string">"data.txt"</span>,<span class="string">"w"</span>);                     <span class="comment">//初次写入的函数，所以用 “w"方式写入 </span></span><br><span class="line">   <span class="keyword">if</span>(!fp)</span><br><span class="line">   &#123;</span><br><span class="line">	   <span class="built_in">printf</span>(<span class="string">"\n打开文件data.txt失败!"</span>);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">   &#123;</span><br><span class="line">	   <span class="built_in">fprintf</span>(fp,<span class="string">"\n%s %s "</span>,s[i].en,s[i].ch);  <span class="comment">//写入字符串（单词） </span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">   fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//实现排序对成绩</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">sort0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> 	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">char</span> temp[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> t; </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num1<span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=num1<span class="number">-1</span>;j&gt;i;j--)</span><br><span class="line">			<span class="keyword">if</span>(r[j<span class="number">-1</span>].core&lt;r[j].core)        <span class="comment">//一个内循环实现将最高的成绩放在第一个位置 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">strcpy</span>(temp,r[j<span class="number">-1</span>].user);            <span class="comment">//用户名交换 </span></span><br><span class="line">				<span class="built_in">strcpy</span>(r[j<span class="number">-1</span>].user,r[j].user);</span><br><span class="line">				<span class="built_in">strcpy</span>(r[j].user,temp);</span><br><span class="line">				t=r[j<span class="number">-1</span>].c;           <span class="comment">//错误单词交换 </span></span><br><span class="line">				r[j<span class="number">-1</span>].c=r[j].c;</span><br><span class="line">				r[j].c=t;</span><br><span class="line">				t=r[j<span class="number">-1</span>].d;           <span class="comment">//正确单词交换 </span></span><br><span class="line">				r[j<span class="number">-1</span>].d=r[j].d;</span><br><span class="line">				r[j].d=t;	</span><br><span class="line">				t=r[j<span class="number">-1</span>].core;           <span class="comment">//成绩交换 </span></span><br><span class="line">				r[j<span class="number">-1</span>].core=r[j].core;</span><br><span class="line">				r[j].core=t;		</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> 	</span><br><span class="line">  &#125; </span><br><span class="line"><span class="comment">//读取用户的成绩 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">readuser</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   FILE *fp;</span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">   fp=fopen(<span class="string">"ranklist.txt"</span>,<span class="string">"r"</span>);   <span class="comment">//“r”方式打开不允许改写文件 </span></span><br><span class="line">   <span class="keyword">if</span>(!fp)                     <span class="comment">//说明没有文件 </span></span><br><span class="line">   &#123;</span><br><span class="line">	   <span class="built_in">printf</span>(<span class="string">"\n打开文件ranklist.txt失败!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span>(<span class="built_in">fscanf</span>(fp,<span class="string">"%s %d %d %d "</span>,r[i].user,&amp;r[i].d,&amp;r[i].c,&amp;r[i].core)==<span class="number">4</span>)  <span class="comment">//以空格符，换行符等为结束标志，返回值为实际读取的字符串个数 </span></span><br><span class="line">   &#123;              </span><br><span class="line">	   i++;                                       <span class="comment">//读取下一个单词 </span></span><br><span class="line">   &#125;</span><br><span class="line">   num1=i;</span><br><span class="line">   <span class="keyword">if</span>(<span class="number">0</span>==i)            </span><br><span class="line">	   <span class="built_in">printf</span>(<span class="string">"\n文件为空，请先创建用户名并参加测试单词！"</span>);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">	   <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">   fclose(fp);                                    <span class="comment">//读取完毕，关闭文件 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//文件写入用户信息 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeuser</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"留下你的名字："</span>); </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,r[num1].user);</span><br><span class="line">	FILE *fp;</span><br><span class="line">	<span class="keyword">int</span> i=num1;</span><br><span class="line">    fp=fopen(<span class="string">"ranklist.txt"</span>,<span class="string">"a"</span>);                     <span class="comment">//</span></span><br><span class="line">	r[i].c=c;</span><br><span class="line">	r[i].d=d;</span><br><span class="line">	r[i].core=<span class="number">10</span>*d<span class="number">-10</span>*c;</span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">"\n%s %d %d %d "</span>,r[i].user,r[i].d,r[i].c,r[i].core);   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    d=<span class="number">0</span>;</span><br><span class="line">    c=<span class="number">0</span>;               <span class="comment">//初始化为0，为下个用户所用 </span></span><br><span class="line">    num1++;            <span class="comment">//用户加一 </span></span><br><span class="line">    sort0();</span><br><span class="line">    fclose(fp);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span><span class="comment">/*按字典排序*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">char</span> temp[MAX_CHAR];</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num<span class="number">-1</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=num<span class="number">-1</span>;j&gt;i;j--)</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(s[j<span class="number">-1</span>].en,s[j].en)&gt;<span class="number">0</span>)        <span class="comment">//一个内循环实现将最短的单词放在第一个位置 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">strcpy</span>(temp,s[j<span class="number">-1</span>].en);            <span class="comment">//英文交换 </span></span><br><span class="line">				<span class="built_in">strcpy</span>(s[j<span class="number">-1</span>].en,s[j].en);</span><br><span class="line">				<span class="built_in">strcpy</span>(s[j].en,temp);</span><br><span class="line">				<span class="built_in">strcpy</span>(temp,s[j<span class="number">-1</span>].ch);            <span class="comment">//中文交换 </span></span><br><span class="line">				<span class="built_in">strcpy</span>(s[j<span class="number">-1</span>].ch,s[j].ch);</span><br><span class="line">				<span class="built_in">strcpy</span>(s[j].ch,temp);			</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//添加单词信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i=num,j,flag=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span>(flag)</span><br><span class="line">	&#123;</span><br><span class="line">		flag=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n请输入单词的英文形式:"</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s[i].en);               <span class="comment">//  </span></span><br><span class="line">		<span class="keyword">if</span>(panduan1(s[i].en)==<span class="number">0</span>) &#123;</span><br><span class="line">			flag=<span class="number">1</span>;          <span class="comment">//continue之后不会结束 </span></span><br><span class="line">			<span class="keyword">continue</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)                           <span class="comment">//遍历一遍文件里的单词，检查有没有重复的单词 </span></span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(s[i].en,s[j].en)==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"已有该单词,请检查后重新录入!\n"</span>);</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>; <span class="comment">/*如有重复立即退出该层循环,提高判断速度,break只跳出了for循环，让用户再次输入*/</span></span><br><span class="line">			&#125;</span><br><span class="line">    </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"\n请输入单词的中文形式:"</span>);</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s[i].ch);</span><br><span class="line">   num++;                                  <span class="comment">//单词数加1 </span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"\n您输入的信息为: 英文: %s 中文: %s  "</span>,s[i].en,s[i].ch);</span><br><span class="line">   sort();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除单词信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span>  en[MAX_CHAR];   <span class="comment">//英文形式</span></span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">"\n请输入你要删除的单词英文形式:"</span>);	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,en);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num;i++)<span class="comment">//先找到该英文形式对应的序号</span></span><br><span class="line">	    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(s[i].en,en)==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j=i;j&lt;num<span class="number">-1</span>;j++) <span class="comment">//单词前移 </span></span><br><span class="line">				 s[j]=s[j+<span class="number">1</span>];       </span><br><span class="line">			num--; <span class="comment">//数量减少 1</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"\n没有这个单词!"</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改单词信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,choose=<span class="number">0</span>,flag=<span class="number">1</span>;<span class="comment">//chooses代表菜单选项标识，flag代表是否找到单词</span></span><br><span class="line">	<span class="keyword">char</span>  en[MAX_CHAR];   <span class="comment">//英文形式</span></span><br><span class="line">	<span class="keyword">while</span>(flag||choose)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n请输入你要修改的单词英文形式:"</span>);	</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,en);</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num;i++)<span class="comment">//先找到该英文形式对应的序号</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(s[i].en,en)==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"\n请输入单词正确的英文形式:"</span>);</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%s"</span>,en);</span><br><span class="line">				</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"\n请输入此单词正确的的中文形式:"</span>);</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s[i].ch);</span><br><span class="line">				</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"\n继续修改请按任意键，返回上一级请选0:"</span>);</span><br><span class="line">				choose=panduan();                     </span><br><span class="line">				<span class="keyword">if</span>(choose==<span class="number">0</span>) <span class="keyword">return</span>;	</span><br><span class="line">			&#125;</span><br><span class="line">		   flag=<span class="number">0</span>;</span><br><span class="line">		      </span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">if</span>(!flag)	 <span class="built_in">printf</span>(<span class="string">"\n没有这个单词!"</span>);                <span class="comment">//设计的真巧妙！ </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单词预览</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>  i=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n单词：     英文：      中文：         "</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n          %-12s%-12s"</span>,s[i].en,s[i].ch);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排行榜预览 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showrank</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE *fp;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	fp=fopen(<span class="string">"ranklist.txt"</span>,<span class="string">"r"</span>);</span><br><span class="line">	sort0();                     <span class="comment">//输出前排序 </span></span><br><span class="line">	<span class="keyword">if</span>(!fp)                     <span class="comment">//说明没有文件 </span></span><br><span class="line">    &#123;</span><br><span class="line">	   <span class="built_in">printf</span>(<span class="string">"\n文件ranklist.txt不存在!请参加测试！"</span>);</span><br><span class="line">	   <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n用户名：   答对单词数：    答错单词数：    成绩："</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n      %-12s%-12d%-12d%-12d"</span>,r[i].user,r[i].d,r[i].c,r[i].core); </span><br><span class="line">	&#125;</span><br><span class="line">	fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询单词（中文查询） </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,choose=<span class="number">0</span>,flag=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span>  ch[MAX_CHAR];   <span class="comment">//中文形式</span></span><br><span class="line">	<span class="keyword">while</span>(choose||flag)</span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"\n请输入你要查询的单词中文形式:"</span>);	</span><br><span class="line">	    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,ch);</span><br><span class="line">    	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num;i++)<span class="comment">//先找到该中文形式对应的序号</span></span><br><span class="line">	    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(s[i].ch,ch)==<span class="number">0</span>)</span><br><span class="line">		&#123;		</span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">"\n英文形式:       中文形式:        "</span>);</span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">"\n   %-12s%12s"</span>,s[i].en,s[i].ch);</span><br><span class="line">			</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n继续查询按任意键，返回上一级请选0:"</span>);</span><br><span class="line">			choose=panduan();</span><br><span class="line">			<span class="keyword">if</span>(choose==<span class="number">0</span>) <span class="keyword">return</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">	    flag=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">   <span class="keyword">if</span>(!flag)	 <span class="built_in">printf</span>(<span class="string">"\n没有这个单词!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询单词（英文查询） </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,choose=<span class="number">0</span>,flag=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span>  en[MAX_CHAR];   <span class="comment">//中文形式</span></span><br><span class="line">	<span class="keyword">while</span>(choose||flag)</span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"\n请输入你要查询的单词英文形式:"</span>);	</span><br><span class="line">	    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,en);</span><br><span class="line">    	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num;i++)<span class="comment">//先找到该中文形式对应的序号</span></span><br><span class="line">	    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(s[i].en,en)==<span class="number">0</span>)</span><br><span class="line">		&#123;		</span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">"\n英文形式:       中文形式:        "</span>);</span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">"\n   %-12s%12s"</span>,s[i].en,s[i].ch);</span><br><span class="line">			</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n继续查询请按任意键，返回上一级请选0:"</span>);</span><br><span class="line">			choose=panduan();</span><br><span class="line">			<span class="keyword">if</span>(choose==<span class="number">0</span>) <span class="keyword">return</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">	    flag=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">   <span class="keyword">if</span>(!flag)	 <span class="built_in">printf</span>(<span class="string">"\n没有这个单词!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询单词的选项</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectword</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x;     <span class="comment">//查询选项</span></span><br><span class="line">	<span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(t)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"请选择查询类型：\n(1)英文查询      （2）中文查询\n"</span>);</span><br><span class="line">	    x=panduan();</span><br><span class="line">	    <span class="keyword">if</span>(x==<span class="number">1</span>)&#123;</span><br><span class="line">	    	search1();</span><br><span class="line">	    	t=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    <span class="keyword">if</span>(x==<span class="number">2</span>)&#123;</span><br><span class="line">	    	search0();</span><br><span class="line">	    	t=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    <span class="keyword">if</span>(x!=<span class="number">1</span>&amp;&amp;x!=<span class="number">2</span>)&#123;</span><br><span class="line">	    	<span class="built_in">printf</span>(<span class="string">"没有这个选项，请重新输入！"</span>);</span><br><span class="line">	    	t=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//中译英测试</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zytest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">char</span> b1[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> z;</span><br><span class="line">    <span class="keyword">int</span> choose=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span>   i;</span><br><span class="line">	srand(time(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">while</span>(choose)</span><br><span class="line">	&#123; </span><br><span class="line">	    i = rand()%num;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n【%s】的英文单词:"</span>,s[i].ch);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,b1);</span><br><span class="line">		<span class="keyword">for</span>(z=<span class="number">0</span>;<span class="built_in">strcmp</span>(b1,s[i].en)!=<span class="number">0</span>;z=z)</span><br><span class="line">		&#123;   <span class="keyword">if</span>(c!=<span class="number">0</span>) </span><br><span class="line">		    &#123;</span><br><span class="line">		     <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">			 <span class="built_in">printf</span>(<span class="string">"少年请重新来过吧！请记住它！错了2遍以上的单词："</span>);  <span class="comment">//对错误的单词进行重复记忆 (完善功能)</span></span><br><span class="line">		     <span class="built_in">printf</span>(<span class="string">"\n英文形式:       中文形式:        "</span>);</span><br><span class="line">	         <span class="built_in">printf</span>(<span class="string">"\n   %-12s%12s"</span>,s[i].en,s[i].ch);</span><br><span class="line">	         <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">			 &#125; </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n输入错误！！请重新输入:"</span>);<span class="built_in">scanf</span>(<span class="string">"%s"</span>,b1);c=c+<span class="number">1</span>; </span><br><span class="line">		&#125;    <span class="comment">//错误加一 </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n恭喜你，回答正确，加10分!\n\n"</span>);d=d+<span class="number">1</span>;              <span class="comment">//正确加一 </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n继续测试请按任意键，返回上一级请选0:"</span>);</span><br><span class="line">		choose=panduan();</span><br><span class="line">		<span class="keyword">if</span>(choose==<span class="number">0</span>) <span class="keyword">return</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//英译中测试</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">yztest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> b1[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> z;</span><br><span class="line">	<span class="keyword">int</span> choose=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span>  i;</span><br><span class="line">	srand(time(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="keyword">while</span>(choose)</span><br><span class="line">	&#123; </span><br><span class="line">	    i = rand()%num;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"【%s】的中文意思:"</span>,s[i].en);</span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,b1);</span><br><span class="line">    	<span class="keyword">for</span>(z=<span class="number">0</span>;<span class="built_in">strcmp</span>(b1,s[i].ch)!=<span class="number">0</span>;z=z)</span><br><span class="line">		&#123;   <span class="keyword">if</span>(c!=<span class="number">0</span>) </span><br><span class="line">		    &#123;</span><br><span class="line">		     <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">			 <span class="built_in">printf</span>(<span class="string">"少年请重新来过吧！请记住它！错了2遍以上的单词："</span>);  <span class="comment">//对错误的单词进行重复记忆 (完善功能)</span></span><br><span class="line">		     <span class="built_in">printf</span>(<span class="string">"\n英文形式:       中文形式:        "</span>);</span><br><span class="line">	         <span class="built_in">printf</span>(<span class="string">"\n   %-12s%12s"</span>,s[i].en,s[i].ch);</span><br><span class="line">	         <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">			 &#125; </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n输入错误！！请重新输入:"</span>);<span class="built_in">scanf</span>(<span class="string">"%s"</span>,b1);c=c+<span class="number">1</span>;</span><br><span class="line">		&#125;    <span class="comment">//错误加一 </span></span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"\n恭喜你,回答正确，加10分!\n\n"</span>);d=d+<span class="number">1</span>;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"\n继续测试请按任意键，返回上一级请选0:"</span>);</span><br><span class="line">	    choose=panduan();  </span><br><span class="line">	    <span class="keyword">if</span>(choose==<span class="number">0</span>) <span class="keyword">return</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成绩列表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n	共计输入错误:%d次	**每次扣10分**\n"</span>,c);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"	共计输入正确:%d次	**每次加10分**\n"</span>,d);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"	你的总得分为:%d分\n\n"</span>,<span class="number">10</span>*d<span class="number">-10</span>*c);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//词典维护</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> choose;<span class="comment">//维护功能选择 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"   ------------------\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"   1.增加单词\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"   2.修改单词\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"   3.删除单词\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"   4.查询单词\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"   5.退出本菜单\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"   ------------------\n"</span>); </span><br><span class="line">   	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;  </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">" \n请输入维护功能编号(按5退出):"</span>);</span><br><span class="line">		choose=panduan();</span><br><span class="line">		<span class="keyword">switch</span>(choose)</span><br><span class="line">		&#123;</span><br><span class="line">		 <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			    system(<span class="string">"cls"</span>);add();writefile();<span class="keyword">break</span>;</span><br><span class="line">		 <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			    system(<span class="string">"cls"</span>);modify();writefile();<span class="keyword">break</span>;</span><br><span class="line">		 <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			    system(<span class="string">"cls"</span>);del();writefile();<span class="keyword">break</span>;</span><br><span class="line">		 <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">		 	    system(<span class="string">"cls"</span>);selectword();<span class="keyword">break</span>;</span><br><span class="line">	 	 <span class="keyword">case</span> <span class="number">5</span>:  <span class="keyword">return</span>;</span><br><span class="line">		 <span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">"\n请在1-5之间选择"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用户界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	<span class="keyword">int</span> item;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">" *********************************************************\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"#                                                       #\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"#                     英语单词小助手                    #\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"#                                                       #\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"#                  版本 ： v1.0（改善版）               #\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"#                                                       #\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">" *********************************************************\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"#                                                       #\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"#                     （1）词库维护                     #\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"#        （2）单词预览            （3）单词背诵(中译英) #\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"#                                                       #\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"#        （4）单词背诵(英译中)    （5）查询成绩         #\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"#                                                       #\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"#        （6）帮助                （7）排行榜           #\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"#                     （8）退出系统                     #\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"#                                                       #\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"#                      单词旅行开始                     #\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"#                                                       #\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">" **********************************************************\n"</span>);  </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"           请选择您需要的操作序号(1-8)按回车确认:"</span>);</span><br><span class="line">	</span><br><span class="line">	item=panduan(); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    readfile();     <span class="comment">//打开文件好进行下一步操作 </span></span><br><span class="line">	<span class="keyword">switch</span>(item)</span><br><span class="line">	&#123;</span><br><span class="line">	 <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		    system(<span class="string">"cls"</span>);<span class="built_in">maintain</span>();<span class="keyword">break</span>;    <span class="comment">//单词维护 </span></span><br><span class="line">	 <span class="keyword">case</span> <span class="number">2</span>: </span><br><span class="line">		    system(<span class="string">"cls"</span>);show();<span class="keyword">break</span>;        <span class="comment">//单词预览 </span></span><br><span class="line">	 <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		    system(<span class="string">"cls"</span>);zytest();writeuser();<span class="keyword">break</span>;      <span class="comment">//中译英 </span></span><br><span class="line">	 <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">		    system(<span class="string">"cls"</span>);yztest();writeuser();<span class="keyword">break</span>;     <span class="comment">//英译中 </span></span><br><span class="line">     <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">		    system(<span class="string">"cls"</span>);<span class="built_in">list</span>();<span class="keyword">break</span>;        <span class="comment">//查成绩 </span></span><br><span class="line">	 <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">		    system(<span class="string">"cls"</span>);help();<span class="keyword">break</span>;        <span class="comment">//帮助 </span></span><br><span class="line">	 <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">	        system(<span class="string">"cls"</span>);readuser();showrank();<span class="keyword">break</span>;</span><br><span class="line">  	 <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">		    select =<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">	 <span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"请在1-8之间选择\n"</span>);</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    system(<span class="string">"color FA"</span>);</span><br><span class="line">  	<span class="keyword">while</span>(select)</span><br><span class="line">	&#123;</span><br><span class="line">		menu();</span><br><span class="line">	&#125;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>三天打鱼两天晒网</title>
    <url>/C/%E4%B8%89%E5%A4%A9%E6%89%93%E9%B1%BC%E4%B8%A4%E5%A4%A9%E6%99%92%E7%BD%91/</url>
    <content><![CDATA[<p>/<strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong>/<br>文件名称：三天打鱼两天晒网<br>编程语言：C++<br>编译器：Visual C++ 6.0<br>完成日期：2019年02月28日<br>作者：无奈¬_¬｀啊</p>
<h1 id="一-问题"><a href="#一-问题" class="headerlink" title="一.问题"></a>一.问题</h1><p>中国有句俗语叫“三天打鱼两天晒网”。某人从2010年1月1日起开始“三天打鱼两天晒网”，问这个人在以后的某一天中是“打鱼”还是“晒网”。用C或C++语言/java/python实现程序解决问题。</p>
<a id="more"></a>
<p><strong>此处我是用C++实现的。</strong><br>基本要求：1.程序风格良好(使用自定义注释模板)，提供友好的输入输出。<br>提高要求：1.输入数据的正确性验证。<br>          2.使用文件进行数据测试。如将日期 20100101   20111214  等数据保存在in.txt文件中，程序读入in.dat文件进行判定，并将结果输出至out.txt文件。</p>
<h1 id="二-思考"><a href="#二-思考" class="headerlink" title="二.思考"></a>二.思考</h1><p> 首先三天打鱼两天晒网，周期为5天，所以只要计算出指定日期到2010年01月01日有多少天，并用这个天数除以5求余数，如果余数是0或者4则说明他在晒网，余数为1，2，3则在打渔，这个不难想象。<br> 接下来我们的主要任务就是求天数，这也是这个问题的核心部分，因为每年的天数不一样，闰年366天，平年365天，所以必须区分好闰年和平年。<br> 可以被4整除而且不被100整除的或者能被400整除的就是闰年，否则是平年。用代码表示则如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(x%4&#x3D;&#x3D;0&amp;&amp;x%100!&#x3D;0||x%400&#x3D;&#x3D;0) temp&#x3D;1;</span><br><span class="line">	else temp&#x3D;0;</span><br></pre></td></tr></table></figure>
<p>temp是1表示闰年，0表示平年。<br>闰年比平年多一天，这个多出来的一天就是2月里28天或者29天，闰年2月有29天。所以在判断日期的正确性的时候需要注意。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(temp&#x3D;&#x3D;0)</span><br><span class="line">				&#123;</span><br><span class="line">					if(z&gt;28)</span><br><span class="line">					&#123;</span><br><span class="line">						cout&lt;&lt;&quot;平年2月只有28天！&quot;;</span><br><span class="line">						exit(0);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>


<p>继续求天数，我们先求出2010年到指定年前一年的天数，然后在细算到月份日份。<br>年份的不同就代表着闰年和平年，所以就麻烦了，你得先判断这段时期之间每一年的年份，然后再决定加多少天。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i&#x3D;2010; i&lt;x; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(temp) t+&#x3D;366;</span><br><span class="line">		else t+&#x3D;365;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>x为指定年份；<br>计算好年份后我们就需要计算月份日份了，计算到指定月份的天数加上指定的日份·，就计算出总天数了；<br>然而又存在大月小月所以加的天数也不同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch(y)</span><br><span class="line">	&#123;</span><br><span class="line">		case 1:</span><br><span class="line">			t+&#x3D;z;</span><br><span class="line">			break;</span><br><span class="line">		case 2:</span><br><span class="line">			t&#x3D;t+31+z;</span><br><span class="line">			break;</span><br><span class="line">		case 3:</span><br><span class="line">		&#123;</span><br><span class="line">			if(temp&#x3D;&#x3D;1) t&#x3D;t+60+z;</span><br><span class="line">			else t&#x3D;t+59+z;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">		case 4:</span><br><span class="line">		&#123;</span><br><span class="line">			if(temp&#x3D;&#x3D;1) t&#x3D;t+91+z;</span><br><span class="line">			else t&#x3D;t+90+z;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">		case 5:</span><br><span class="line">		&#123;</span><br><span class="line">			if(temp&#x3D;&#x3D;1) t&#x3D;t+121+z;</span><br><span class="line">			else t&#x3D;t+120+z;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">		case 6:</span><br><span class="line">		&#123;</span><br><span class="line">			if(temp&#x3D;&#x3D;1) t&#x3D;t+152+z;</span><br><span class="line">			else t&#x3D;t+151+z;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">		case 7:</span><br><span class="line">		&#123;</span><br><span class="line">			if(temp&#x3D;&#x3D;1) t&#x3D;t+182+z;</span><br><span class="line">			else t&#x3D;t+181+z;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">		case 8:</span><br><span class="line">		&#123;</span><br><span class="line">			if(temp&#x3D;&#x3D;1) t&#x3D;t+213+z;</span><br><span class="line">			else t&#x3D;t+212+z;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">		case 9:</span><br><span class="line">		&#123;</span><br><span class="line">			if(temp&#x3D;&#x3D;1) t&#x3D;t+244+z;</span><br><span class="line">			else t&#x3D;t+243+z;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">		case 10:</span><br><span class="line">		&#123;</span><br><span class="line">			if(temp&#x3D;&#x3D;1) t&#x3D;t+274+z;</span><br><span class="line">			else t&#x3D;t+273+z;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">		case 11:</span><br><span class="line">		&#123;</span><br><span class="line">			if(temp&#x3D;&#x3D;1) t&#x3D;t+305+z;</span><br><span class="line">			else t&#x3D;t+304+z;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">		case 12:</span><br><span class="line">		&#123;</span><br><span class="line">			if(temp&#x3D;&#x3D;1) t&#x3D;t+335+z;</span><br><span class="line">			else t&#x3D;t+334+z;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">		default:</span><br><span class="line">			cout&lt;&lt;&quot;输入有误，请重新输入！&quot;;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法有点笨，需要自己算出加多少天，也可以用数组来加，奈何我有点不理解所以用那个这个笨办法了）：<br>最后让我们加上日份就大功告成了也就是上面的z,y表示的是月，z表示日。<br>不要大意了，还要判断日期的正确性，闰年2月28天，大月小月，不多阐述，代码献上:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(y&lt;0||y&gt;12)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;&quot;读取的月份错误，请重新输入！&quot;;</span><br><span class="line">	exit(0);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">	if(z&lt;0||z&gt;31)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;&quot;读取的日份错误，请重新输入！&quot;;</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		if(y&#x3D;&#x3D;2)</span><br><span class="line">		&#123;</span><br><span class="line">			if(z&gt;29)</span><br><span class="line">			&#123;</span><br><span class="line">				cout&lt;&lt;&quot;2月最多有29号！&quot;;</span><br><span class="line">				exit(0);</span><br><span class="line">			&#125;</span><br><span class="line">			if(temp&#x3D;&#x3D;0)</span><br><span class="line">			&#123;</span><br><span class="line">				if(z&gt;28)</span><br><span class="line">				&#123;</span><br><span class="line">					cout&lt;&lt;&quot;平年2月只有28天！&quot;;</span><br><span class="line">					exit(0);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if(temp&#x3D;&#x3D;1)</span><br><span class="line">			&#123;</span><br><span class="line">				if(z&gt;29)</span><br><span class="line">				&#123;</span><br><span class="line">					cout&lt;&lt;&quot;平年2月只有29天！&quot;;</span><br><span class="line">					exit(0);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			if(y&#x3D;&#x3D;4||y&#x3D;&#x3D;6||y&#x3D;&#x3D;9||y&#x3D;&#x3D;11)</span><br><span class="line">				if(z&gt;30)</span><br><span class="line">				&#123;</span><br><span class="line">					cout&lt;&lt;&quot;小月不能超过30天&quot;;</span><br><span class="line">					exit(0);</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的最后就是文件操作了，需要用到ofstream类和ifstream类，通过文件流对象进行操作。<br>通过键盘将年月日输入保存到in.txt文件里，然后通过文件流对象的操作，读取in.txt里的内容并放到in.dat文件里，在读取出来进行操作，将结果输出到out.txt文件里；以上对文件的操作都是在D:\gyy\ 路径下操作，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int x,y,z;</span><br><span class="line">	int a[3];</span><br><span class="line">	ofstream outfile(&quot;d:\\gyy\\in.txt&quot;,ios::out);   &#x2F;&#x2F;创建一个in.txt用来保存文件</span><br><span class="line">	cout&lt;&lt;&quot;请输入日期：&quot;&lt;&lt;endl;</span><br><span class="line">	for(int i&#x3D;0; i&lt;3; i++)                          &#x2F;&#x2F;以数组的形式保存</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		outfile&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	ifstream infile(&quot;d:\\gyy\\in.txt&quot;,ios::in);    &#x2F;&#x2F;以下四行代码实现将in.txt里的数据读入到in.dat文件里</span><br><span class="line">	ofstream outfile1(&quot;d:\\gyy\\in.dat&quot;,ios::out); &#x2F;&#x2F;1</span><br><span class="line">	for(i&#x3D;0; i&lt;3; i++)                             &#x2F;&#x2F;2</span><br><span class="line">	&#123;</span><br><span class="line">		infile&gt;&gt;a[i];                              &#x2F;&#x2F;3</span><br><span class="line">		outfile1&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;                          &#x2F;&#x2F;4</span><br><span class="line">	infile.open(&quot;d:\\gyy\\in.dat&quot;,ios::in);        &#x2F;&#x2F;以下3行代码将in.dat里的数据读取并赋值给对应的日期</span><br><span class="line">	for(i&#x3D;0; i&lt;3; i++)                             &#x2F;&#x2F;1</span><br><span class="line">		infile&gt;&gt;a[i];                              &#x2F;&#x2F;2</span><br><span class="line">	x&#x3D;a[0];</span><br><span class="line">	y&#x3D;a[1];</span><br><span class="line">	z&#x3D;a[2];                        &#x2F;&#x2F;3</span><br><span class="line"></span><br><span class="line">	nf(x);                                       &#x2F;&#x2F;判断闰年还是平年；</span><br><span class="line">	panduan(y,z);                               &#x2F;&#x2F;判断日期的正确性</span><br><span class="line">	display(x);                                 &#x2F;&#x2F;计算2010到指定日期前一年是经过多少天</span><br><span class="line">	display1(y,z);                               &#x2F;&#x2F;细算到指定日期的那天</span><br><span class="line"></span><br><span class="line">	ofstream outfile2(&quot;d:\\gyy\\out.txt&quot;,ios::out);&#x2F;&#x2F;创建一个输出文件out.txt</span><br><span class="line">	int b&#x3D;t%5;</span><br><span class="line">	if(b&lt;4&amp;&amp;b!&#x3D;0) outfile2&lt;&lt;&quot;小明在打渔！&quot;;       &#x2F;&#x2F;向out.txt文件输入结果</span><br><span class="line">	else outfile2&lt;&lt;&quot;小明在晒网！&quot;;</span><br><span class="line">	infile.close();</span><br><span class="line">	outfile.close();</span><br><span class="line">	outfile1.close();</span><br><span class="line">	outfile2.close();</span><br></pre></td></tr></table></figure>
<h1 id="三-总结·"><a href="#三-总结·" class="headerlink" title="三.总结·"></a>三.总结·</h1><p>这次的程序设计，给予了我一点小喜悦，通过自己的努力，查阅书籍，结合自己的知识做出来的程序，虽然有点冗杂，但是总的来说功能是完善的，就是代码写的过于冗杂，在判断日期的正确性是用了太多的if else语句，完全可以改进为对数组操作将12个月份的数据放在数组中，需要就提取很方便（自我检讨一下）；<br>三天打鱼俩天网究竟是褒义还是贬义，潜意识中是认为做事不专心，这俩天在学习这个，过俩天又在做其他事。所以做出这个程序后我也希望可以以后的我也不再三天打鱼两天晒网了！！！<br><strong>（纪念我的第一篇博客！）</strong></p>
<p>最后附上完整版代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Time</span><br><span class="line">&#123;</span><br><span class="line">	private:</span><br><span class="line">		int t;&#x2F;&#x2F;表示天数</span><br><span class="line">		int temp;&#x2F;&#x2F;判断闰年，平年的条件，1代表闰年</span><br><span class="line">	public:</span><br><span class="line">		void nf(int);&#x2F;&#x2F;判断年份的闰平</span><br><span class="line">		void panduan(int,int);&#x2F;&#x2F;判断日期的正确性</span><br><span class="line">		void display(int);&#x2F;&#x2F;返回2010年到指定年份前一年的总天数</span><br><span class="line">		void display1(int,int);</span><br><span class="line">		void fileoperation();</span><br><span class="line">&#125;;</span><br><span class="line">void Time::nf(int x)                  &#x2F;&#x2F;先判断这个是否为闰年</span><br><span class="line">&#123;</span><br><span class="line">	if(x&lt;2010) cout&lt;&lt;&quot;读取的年份太小!，请重新输入！&quot;;</span><br><span class="line">	if(x%4&#x3D;&#x3D;0&amp;&amp;x%100!&#x3D;0||x%400&#x3D;&#x3D;0) temp&#x3D;1;</span><br><span class="line">	else temp&#x3D;0;</span><br><span class="line">&#125;</span><br><span class="line">void Time::display(int x)            &#x2F;&#x2F;返回2010年到指定年份前一年的总天数</span><br><span class="line">&#123;</span><br><span class="line">	for(int i&#x3D;2010; i&lt;x; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(temp) t+&#x3D;366;</span><br><span class="line">		else t+&#x3D;365;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void Time::display1(int y,int z)</span><br><span class="line">&#123;</span><br><span class="line">	t&#x3D;0;</span><br><span class="line">	switch(y)</span><br><span class="line">	&#123;</span><br><span class="line">		case 1:</span><br><span class="line">			t+&#x3D;z;</span><br><span class="line">			break;</span><br><span class="line">		case 2:</span><br><span class="line">			t&#x3D;t+31+z;</span><br><span class="line">			break;</span><br><span class="line">		case 3:</span><br><span class="line">		&#123;</span><br><span class="line">			if(temp&#x3D;&#x3D;1) t&#x3D;t+60+z;</span><br><span class="line">			else t&#x3D;t+59+z;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">		case 4:</span><br><span class="line">		&#123;</span><br><span class="line">			if(temp&#x3D;&#x3D;1) t&#x3D;t+91+z;</span><br><span class="line">			else t&#x3D;t+90+z;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">		case 5:</span><br><span class="line">		&#123;</span><br><span class="line">			if(temp&#x3D;&#x3D;1) t&#x3D;t+121+z;</span><br><span class="line">			else t&#x3D;t+120+z;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">		case 6:</span><br><span class="line">		&#123;</span><br><span class="line">			if(temp&#x3D;&#x3D;1) t&#x3D;t+152+z;</span><br><span class="line">			else t&#x3D;t+151+z;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">		case 7:</span><br><span class="line">		&#123;</span><br><span class="line">			if(temp&#x3D;&#x3D;1) t&#x3D;t+182+z;</span><br><span class="line">			else t&#x3D;t+181+z;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">		case 8:</span><br><span class="line">		&#123;</span><br><span class="line">			if(temp&#x3D;&#x3D;1) t&#x3D;t+213+z;</span><br><span class="line">			else t&#x3D;t+212+z;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">		case 9:</span><br><span class="line">		&#123;</span><br><span class="line">			if(temp&#x3D;&#x3D;1) t&#x3D;t+244+z;</span><br><span class="line">			else t&#x3D;t+243+z;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">		case 10:</span><br><span class="line">		&#123;</span><br><span class="line">			if(temp&#x3D;&#x3D;1) t&#x3D;t+274+z;</span><br><span class="line">			else t&#x3D;t+273+z;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">		case 11:</span><br><span class="line">		&#123;</span><br><span class="line">			if(temp&#x3D;&#x3D;1) t&#x3D;t+305+z;</span><br><span class="line">			else t&#x3D;t+304+z;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">		case 12:</span><br><span class="line">		&#123;</span><br><span class="line">			if(temp&#x3D;&#x3D;1) t&#x3D;t+335+z;</span><br><span class="line">			else t&#x3D;t+334+z;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">		default:</span><br><span class="line">			cout&lt;&lt;&quot;输入有误，请重新输入！&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void Time::panduan(int y,int z)</span><br><span class="line">&#123;</span><br><span class="line">	if(y&lt;0||y&gt;12)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;&quot;读取的月份错误，请重新输入！&quot;;</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		if(z&lt;0||z&gt;31)</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;&quot;读取的日份错误，请重新输入！&quot;;</span><br><span class="line">			exit(0);</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			if(y&#x3D;&#x3D;2)</span><br><span class="line">			&#123;</span><br><span class="line">				if(z&gt;29)</span><br><span class="line">				&#123;</span><br><span class="line">					cout&lt;&lt;&quot;2月最多有29号！&quot;;</span><br><span class="line">					exit(0);</span><br><span class="line">				&#125;</span><br><span class="line">				if(temp&#x3D;&#x3D;0)</span><br><span class="line">				&#123;</span><br><span class="line">					if(z&gt;28)</span><br><span class="line">					&#123;</span><br><span class="line">						cout&lt;&lt;&quot;平年2月只有28天！&quot;;</span><br><span class="line">						exit(0);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				if(temp&#x3D;&#x3D;1)</span><br><span class="line">				&#123;</span><br><span class="line">					if(z&gt;29)</span><br><span class="line">					&#123;</span><br><span class="line">						cout&lt;&lt;&quot;平年2月只有29天！&quot;;</span><br><span class="line">						exit(0);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">				if(y&#x3D;&#x3D;4||y&#x3D;&#x3D;6||y&#x3D;&#x3D;9||y&#x3D;&#x3D;11)</span><br><span class="line">					if(z&gt;30)</span><br><span class="line">					&#123;</span><br><span class="line">						cout&lt;&lt;&quot;小月不能超过30天&quot;;</span><br><span class="line">						exit(0);</span><br><span class="line">					&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void Time::fileoperation()</span><br><span class="line">&#123;</span><br><span class="line">	int x,y,z;</span><br><span class="line">	int a[3];</span><br><span class="line">	ofstream outfile(&quot;d:\\gyy\\in.txt&quot;,ios::out);   &#x2F;&#x2F;创建一个in.txt用来保存文件</span><br><span class="line">	cout&lt;&lt;&quot;请输入日期：&quot;&lt;&lt;endl;</span><br><span class="line">	for(int i&#x3D;0; i&lt;3; i++)                          &#x2F;&#x2F;以数组的形式保存</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		outfile&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	ifstream infile(&quot;d:\\gyy\\in.txt&quot;,ios::in);    &#x2F;&#x2F;以下四行代码实现将in.txt里的数据读入到in.dat文件里</span><br><span class="line">	ofstream outfile1(&quot;d:\\gyy\\in.dat&quot;,ios::out); &#x2F;&#x2F;1</span><br><span class="line">	for(i&#x3D;0; i&lt;3; i++)                             &#x2F;&#x2F;2</span><br><span class="line">	&#123;</span><br><span class="line">		infile&gt;&gt;a[i];                              &#x2F;&#x2F;3</span><br><span class="line">		outfile1&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;                          &#x2F;&#x2F;4</span><br><span class="line">	infile.open(&quot;d:\\gyy\\in.dat&quot;,ios::in);        &#x2F;&#x2F;以下3行代码将in.dat里的数据读取并赋值给对应的日期</span><br><span class="line">	for(i&#x3D;0; i&lt;3; i++)                             &#x2F;&#x2F;1</span><br><span class="line">		infile&gt;&gt;a[i];                              &#x2F;&#x2F;2</span><br><span class="line">	x&#x3D;a[0];</span><br><span class="line">	y&#x3D;a[1];</span><br><span class="line">	z&#x3D;a[2];                        &#x2F;&#x2F;3</span><br><span class="line"></span><br><span class="line">	nf(x);                                       &#x2F;&#x2F;判断闰年还是平年；</span><br><span class="line">	panduan(y,z);                               &#x2F;&#x2F;判断日期的正确性</span><br><span class="line">	display(x);                                 &#x2F;&#x2F;计算2010到指定日期前一年是经过多少天</span><br><span class="line">	display1(y,z);                               &#x2F;&#x2F;细算到指定日期的那天</span><br><span class="line"></span><br><span class="line">	ofstream outfile2(&quot;d:\\gyy\\out.txt&quot;,ios::out);&#x2F;&#x2F;创建一个输出文件out.txt</span><br><span class="line">	int b&#x3D;t%5;</span><br><span class="line">	if(b&lt;4&amp;&amp;b!&#x3D;0) outfile2&lt;&lt;&quot;小明在打渔！&quot;;       &#x2F;&#x2F;向out.txt文件输入结果</span><br><span class="line">	else outfile2&lt;&lt;&quot;小明在晒网！&quot;;</span><br><span class="line">	infile.close();</span><br><span class="line">	outfile.close();</span><br><span class="line">	outfile1.close();</span><br><span class="line">	outfile2.close();</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Time q;</span><br><span class="line">	q.fileoperation();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/%E6%8E%92%E5%BA%8F/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>1.1 排序</p>
</li>
<li><p>排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。<br>平时的上下文中，如果提到排序，通常指的是排升序（非降序）。<br>通常意义上的排序，都是指的原地排序(in place sort)。*</p>
</li>
<li><p>1.2 稳定性</p>
</li>
<li><p>两个相等的数据，如果经过排序后，排序算法能保证其相对位置不发生变化，则我们称该算法是具备稳定性的排序<br>算法。*</p>
<p> <em>9  ,  5  ,  2  ,  7  ,  12  ,  2  ,  4  ,  6  ,  9  ,  23<br> 排序后<br> 前面的 2 依旧在后面的 2 的后面那么称这个算法具有稳定性</em></p>
</li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序实际上就是在遍历的同时选择出最小的元素放在前面，第一次选出最小的放在第一位，第二次选择出次小的放在第二位。。。后面按照相同的步骤就可以使数组有序。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//直接选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="comment">//这里写成i &lt; array.length - 1;因为当你排完前面的序，最后一个就默认有序了，所以遍历到倒数第二个就结束了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j &lt; array.length - <span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="comment">//小于号保证了稳定性</span></span><br><span class="line">            <span class="keyword">if</span>(array[j] &lt; array[minIndex])&#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(array,i,minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> minIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = array[minIndex];</span><br><span class="line">    array[minIndex] = array[i];</span><br><span class="line">    array[i] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>选择排序是稳定的，在比较条件不写等于号就可以避免破坏数据的相对位置！</p>
<p>优化：在遍历的同时记录最大最小值，将最小值放在前面，最大值放在最后，这样效率就会提升，遍历的次数就少了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort2</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> right = array.length - <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">         <span class="keyword">int</span> minIndex = left;</span><br><span class="line">         <span class="keyword">int</span> maxIndex = left;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = left + <span class="number">1</span>;i &lt;= right;i++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(array[i] &lt; array[minIndex])&#123;</span><br><span class="line">                 minIndex = i;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span>(array[i] &gt; array[maxIndex])&#123;</span><br><span class="line">                 maxIndex = i;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         swap(array,left,minIndex);</span><br><span class="line">         <span class="keyword">if</span>(maxIndex == left)&#123;</span><br><span class="line">             maxIndex = minIndex;</span><br><span class="line">         &#125;</span><br><span class="line">         swap(array,right,maxIndex);</span><br><span class="line">         left++;</span><br><span class="line">         right--;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p><strong>需要注意的地方：</strong><br>            if(maxIndex == left){<br>                maxIndex = minIndex;<br>            }<br>这里是为了防止最大的元素在最左边被交换掉位置！比如：</p>
<p><strong>9     5      1      7       3        2<br>left = 0;      right = 5;<br>maxIndex = 0; minIndex = 2;<br>如果不加这个条件，当将最小的交换到最左边后，其实maxIndex已经不为0了。而变成了2，所以只要将maxIndex = minIndex;就可以了</strong></p>
<p>注：如有运行错误，请评论一下我尽快更改，谢谢啦！</p>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/%E6%8E%92%E5%BA%8F/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>1.1 排序</p>
</li>
<li><p>排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。<br>平时的上下文中，如果提到排序，通常指的是排升序（非降序）。<br>通常意义上的排序，都是指的原地排序(in place sort)。*</p>
</li>
<li><p>1.2 稳定性</p>
</li>
<li><p>两个相等的数据，如果经过排序后，排序算法能保证其相对位置不发生变化，则我们称该算法是具备稳定性的排序<br>算法。*</p>
<p> <em>9  ,  5  ,  2  ,  7  ,  12  ,  2  ,  4  ,  6  ,  9  ,  23<br> 排序后<br> 前面的 2 依旧在后面的 2 的后面那么称这个算法具有稳定性</em></p>
</li>
</ul>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><a href="https://blog.csdn.net/qq_42419462/article/details/101382639" target="_blank" rel="noopener">想要了解希尔排序需要先了解直接插入排序（希尔排序是直接插入排序的优化）</a></p>
<p>  9  ,  5  ,  2  ,  7  ,  12  ,  2  ,  4  ,  6  ,  9  ,  23</p>
<p>基本思想是一样。<br>希尔排序你可以将其理解为分组进行插入排序。（跳着排序）<br>先将数组变为一个近似有序的数组。然后逐渐逼近。<br>这里利用一个变量（gap）实现分组。<br>gap代表间隙，一次移动的步数，因为移动的步数是跳着走的所以比起直接插入排序的一步一步走快！！！<br>继续下去数组最后就会有序</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分组交换的插入排序(gap表示间隙)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSortWithGap</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> gap)</span></span>&#123;</span><br><span class="line">    <span class="comment">//这里交换的思想与直接插入排序一样，只是跳着比较，不是一个个比较，排完后，数组近似有序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; array.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> key = array[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - gap;</span><br><span class="line">        <span class="comment">//同样的这里写大于是为了保证稳定性</span></span><br><span class="line">        <span class="keyword">for</span>(; j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; key;j-=gap)&#123;</span><br><span class="line">            array[j+gap] = array[j];</span><br><span class="line">        &#125;</span><br><span class="line">        array[j+gap] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = array.length;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        gap= (gap / <span class="number">3</span>) + <span class="number">1</span>;<span class="comment">//这里也可以写gap = gap / 2;  这是很多人总结出来分的间隔最适合的(也就是跳跃的步骤)</span></span><br><span class="line">        insertSortWithGap(array,gap);</span><br><span class="line">        <span class="comment">//如果gap==1说明排序方法以及按照一个个的比较排序过了，则说明数组已经处于有序了</span></span><br><span class="line">        <span class="comment">//所以直接跳出即可</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == gap)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>1.希尔排序是不稳定的，因为分组的时候，两个一样的数可能没有被分到一起，一个跳到另一个后面也是可能的！<br>2.gap的取值可以自己定义；但推荐两种：<br>（1）gap = gap / 2;<br>（2）gap = gap / 3 + 1;</p>
<p>注：如有运行错误，请评论一下我尽快更改，谢谢啦！</p>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>直接插入排序</title>
    <url>/%E6%8E%92%E5%BA%8F/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>1.1 排序</p>
</li>
<li><p>排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。<br>平时的上下文中，如果提到排序，通常指的是排升序（非降序）。<br>通常意义上的排序，都是指的原地排序(in place sort)。*</p>
</li>
<li><p>1.2 稳定性</p>
</li>
<li><p>两个相等的数据，如果经过排序后，排序算法能保证其相对位置不发生变化，则我们称该算法是具备稳定性的排序<br>算法。*</p>
<p> <em>9  ,  5  ,  2  ,  7  ,  12  ,  2  ,  4  ,  6  ,  9  ,  23<br> 排序后<br> 前面的 2 依旧在后面的 2 的后面那么称这个算法具有稳定性</em></p>
</li>
</ul>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>整个区间被分为</p>
<ol>
<li><p>有序区间</p>
</li>
<li><p>无序区间<br>每次选择无序区间的第一个元素，在有序区间内选择合适的位置插入，随着数组的遍历完成以及元素的插入，数组就有序起来</p>
<p>9  ,  5  ,  2  ,  7  ,  12  ,  2  ,  4  ,  6  ,  9  ,  23</p>
</li>
</ol>
<p>（1）利用key记住5<br>（2）从5开始，我们默认第一个元素有序，拿5和9比较，比9小，<br>9向后移动<br>（3）5继续比较发现没有元素，那么将5插入成第一个元素<br>（4）数组变为了 5，9， 2  ,  7  ,  12  ,  2  ,  4  ,  6  ,  9  ,  23<br>（5）现在认为有序区间有两个元素，所以在无序区间继续选择<br>（6）利用key记住2<br>（7）我们拿2和9比较，比9小，9向后移动<br>（8）数组变为了5，9，9，7，12，2，4，6，9，23<br>（9）在拿2和5比较，比5小，5向后移动<br>（10）数组变为了 5，5，9，7，12，2，4，6，9，23<br>（11）2没有要比的元素，将其插入<br>（12）数组变为了2，5，9，7，12，2，4，6，9，23<br>.。。。<br>继续下去数组最后就会有序</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="comment">//从1开始是因为我们默认第一个元素是有序的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; array.length;i++)&#123;</span><br><span class="line">        <span class="comment">//这里用变量记住这个要进行插入的数据</span></span><br><span class="line">        <span class="keyword">int</span> key = array[i];</span><br><span class="line">        <span class="comment">//j表示有序区间的最后一个下标（从后往前比较）</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果有序区间的元素大那么有序区间向后移动，让key进行插入。（这就是为什么要用key记住插入的数据</span></span><br><span class="line">        <span class="comment">// 防止被移动的有序元素覆盖掉，大于号是为了保证稳定性）</span></span><br><span class="line">        <span class="keyword">for</span>(; j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; key;j--)&#123;</span><br><span class="line">            array[j+<span class="number">1</span>] = array[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//j+1才是真正要插入的地方</span></span><br><span class="line">        array[j+<span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<br>直接插入排序是一种稳定的算法，因为它是按照原本数组的顺序一步步向后遍历的，插入的时候移动条件是大于才移动。<br>所以等于的时候数组没有进行改变，这就保证了数组的稳定性！<br>注：如有运行错误，请评论一下我尽快更改，谢谢啦！</p>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序</title>
    <url>/%E6%8E%92%E5%BA%8F/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>1.1 排序</p>
</li>
<li><p>排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。<br>平时的上下文中，如果提到排序，通常指的是排升序（非降序）。<br>通常意义上的排序，都是指的原地排序(in place sort)。*</p>
</li>
<li><p>1.2 稳定性</p>
</li>
<li><p>两个相等的数据，如果经过排序后，排序算法能保证其相对位置不发生变化，则我们称该算法是具备稳定性的排序<br>算法。*</p>
<p> <em>9  ,  5  ,  2  ,  7  ,  12  ,  2  ,  4  ,  6  ,  9  ,  23<br> 排序后<br> 前面的 2 依旧在后面的 2 的后面那么称这个算法具有稳定性</em></p>
</li>
</ul>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>其基本思想其实就是选择排序，只是寻求最大值的方式不同。选择排序是通过遍历求最大值（最小值），而堆排序是通过大堆的特性寻求最大值的，效率更高效一些。<br>大堆的实质其实就是数组。<br>堆首元素就是0号下标对应的元素。所以只需要交换0号下标的元素到末尾即可。</p>
<p>注意的地方：交换完元素后，堆的特性可能就被破环了，所以当交换完成后一定要对改变后的堆进行调整（这里我才用的是向下调整）</p>
<p>所以我们的第一步就是建堆(建堆需要用到堆的调整方法见下文)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">creatBigHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = (array.length-<span class="number">2</span>) / <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">        shiftDownBig(array,i,array.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调整堆的方法（这是向下调整大堆）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向下调整大堆</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shiftDownBig</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> i,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="number">2</span> * i + <span class="number">1</span> &lt; size)&#123;</span><br><span class="line">          <span class="comment">//这里默认为左孩子最大</span></span><br><span class="line">          <span class="keyword">int</span> max = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(max + <span class="number">1</span> &lt; size &amp;&amp; array[max] &lt; array[max + <span class="number">1</span>])&#123;</span><br><span class="line">              max = max + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(array[i] &gt;= array[max])&#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          swap(array,i,max);</span><br><span class="line">          i = max;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是进行交换元素实现堆排序了<br><strong>(注意这里读不懂可以将i代入0去读会更清晰)：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">     <span class="comment">//建大堆</span></span><br><span class="line">     creatBigHeap(array);</span><br><span class="line">     <span class="comment">//将最大的元素放在数组后面（这里i控制的是循环次数不要多想，比如n个元素只需要9次调整就可有序；）</span></span><br><span class="line">     <span class="comment">//和选择排序有点类似</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">         <span class="comment">//因为大堆的首元素就是数组中的最大值，所以直接交换(永远和无序区间最后一个交换)</span></span><br><span class="line">         swap(array,<span class="number">0</span>,array.length-i-<span class="number">1</span>);</span><br><span class="line">         <span class="comment">//交换完毕后可能会破坏堆的完整性所以需要调整</span></span><br><span class="line">         shiftDownBig(array,<span class="number">0</span>,array.length-i-<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<p>总结：<br>堆排序是不稳定的，在堆的调整过程中非常容易将元素的相对位置改变。<br><strong>注意：排升序建大堆，排降序建小堆（都是与最后的元素交换）<br>大堆将大的元素交换到最后最后形成的数组就是升序！<br>反之，小堆将小的元素交换到后面，最后形成的数组就是降序的！</strong></p>
<p>注：如有运行错误，请评论一下我尽快更改，谢谢啦！</p>
]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/%E6%8E%92%E5%BA%8F/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>时间：2019年04月16日（周二）下午15:47<br>今天，突然想写一下快速排序，以前做过排序的比较，但是忘记的差不多了。这次回忆一下，下面是我在百度百科找到的关于快速排序的定义：</p>
<p>快速排序（Quicksort）是对冒泡排序的一种改进。<br>快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p>看完这段话，思路很清晰，一句话就是把要排序的数据变成俩部分嘛，左边都比右边小，当然我觉得还是说成三部分比较好！因为要有一个中间变量判断，小于这个中间变量的在左边，大于的在右边，就这么简单！</p>
<p>思路：<br>那又有人问了，左边小右边大，那顺序还不一定排好，比如：<br>3  ，  2    ，1  ，  7   ，9 ，  8<br>数字7的左边都小于7，右边都大于7，顺序没有排好。所以接下来我们就要用到递归了，一次排序后，你再对3到7排一次序，一直到全部排好。左边排好后在对右边进行一样的操作就好了。</p>
<p>详细步骤：(数组a[N],这里N为6，存放的数字就是上面那六个数字)<br>1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br>2）以第一个数组元素作为中间变量，赋值给key，即key=a[0]；<br>3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值a[j]，将a[j]和a[i]的值交换；<br>4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的a[i]，将a[i]和a[j]的值交换；<br>5）重复第3、4步，直到i=j;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Quick</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = low;</span><br><span class="line">	<span class="keyword">int</span> j = high;</span><br><span class="line">	<span class="keyword">int</span> key = a[low];</span><br><span class="line">	<span class="keyword">while</span>(i&lt;j) &#123;<span class="comment">//一趟快排，当i,j不等时，一直找下去，最后就达到key左边小于key,key右边大于key</span></span><br><span class="line">		<span class="keyword">while</span>(i&lt;j&amp;&amp;a[j]&gt;key) </span><br><span class="line">			j--;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;j) &#123;</span><br><span class="line">			a[i] = a[j];</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;j&amp;&amp;a[i]&lt;key)</span><br><span class="line">			i++;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;j) &#123;</span><br><span class="line">			a[j] = a[i];</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		a[i] = key;<span class="comment">//最后将关键词赋值给坑</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(low &lt; i-<span class="number">1</span>)</span><br><span class="line">		Quick(a,low,i-<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(high &gt; i+<span class="number">1</span>)</span><br><span class="line">		Quick(a,i+<span class="number">1</span>,high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面最外层的while循环就是实现一次快排，找啊找啊找，一直到i==j<br>这里有一个不容易理解的地方：<br>就是交换值的时候，直接将一个值赋给另一个值了，完全覆盖了，给人感觉就会造成数据丢失，不过不要担心。我们来走一遍！</p>
<p><img data-src="https://img-blog.csdnimg.cn/201904161637106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDE5NDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>所以完全不必担心数据的丢失！<br>下面我将我的测试代码献上，一起学习，如果有错的地方请提出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> zy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quicksort</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Quick</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = low;</span><br><span class="line">	<span class="keyword">int</span> j = high;</span><br><span class="line">	<span class="keyword">int</span> key = a[low];</span><br><span class="line">	<span class="keyword">while</span>(i&lt;j) &#123;<span class="comment">//一趟快排，当i,j不等时，一直找下去，最后就达到key左边小于key,key右边大于key</span></span><br><span class="line">		<span class="keyword">while</span>(i&lt;j&amp;&amp;a[j]&gt;key) </span><br><span class="line">			j--;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;j) &#123;</span><br><span class="line">			a[i] = a[j];</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;j&amp;&amp;a[i]&lt;key)</span><br><span class="line">			i++;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;j) &#123;</span><br><span class="line">			a[j] = a[i];</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		a[i] = key;<span class="comment">//最后将关键词赋值给坑</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(low &lt; i-<span class="number">1</span>)</span><br><span class="line">		Quick(a,low,i-<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(high &gt; i+<span class="number">1</span>)</span><br><span class="line">		Quick(a,i+<span class="number">1</span>,high);</span><br><span class="line">&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">25</span>,<span class="number">24</span>,<span class="number">12</span>,<span class="number">76</span>,<span class="number">101</span>,<span class="number">96</span>,<span class="number">28</span>&#125;;</span><br><span class="line">        Quick(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:a)</span><br><span class="line">        	System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>优先级队列（堆）</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%88%E5%A0%86%EF%BC%89/</url>
    <content><![CDATA[<h2 id="实现一个优先级队列"><a href="#实现一个优先级队列" class="headerlink" title="实现一个优先级队列"></a>实现一个优先级队列</h2><p>内部方法：<br>（1）建大（小）堆<br>（2）调整堆<br>（3）入队列<br>（4）出队列<br>实现的是一个大堆的优先级队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test_9_22;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPriorityQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyPriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">16</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = array[index1];</span><br><span class="line">        array[index1] = array[index2];</span><br><span class="line">        array[index2] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向下调整小堆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shiftDownSmall</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> i,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">2</span> * i + <span class="number">1</span> &lt; size)&#123;</span><br><span class="line">            <span class="comment">//i写成1</span></span><br><span class="line">            <span class="keyword">int</span> min = <span class="number">2</span> * i +<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(min + <span class="number">1</span> &lt; size &amp;&amp; array[min] &gt; array[min+<span class="number">1</span>])&#123;</span><br><span class="line">                min = min+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(array[i] &lt;= array[min])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(array, i, min);</span><br><span class="line">            i = min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//向下调整大堆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shiftDownBig</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> i,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">2</span> * i +<span class="number">1</span> &lt; size)&#123;</span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">2</span> * i +<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//比两个都大，那就比两个孩子中最大的大</span></span><br><span class="line">            <span class="keyword">if</span>(max + <span class="number">1</span> &lt; size &amp;&amp; array[max] &lt; array[max+<span class="number">1</span>])&#123;</span><br><span class="line">                max = max+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(array[i] &gt;= array[max])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(array,i,max);</span><br><span class="line">            i = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建小堆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createSmallHeap</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = (size-<span class="number">2</span>)/<span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            shiftDownSmall(array,i,size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向上调整</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shiftUpSmall</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> parent = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[parent] &gt; array[i])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(array,i,parent);</span><br><span class="line">            i = parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建大堆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">creatBigHeap</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = (size-<span class="number">2</span>)/<span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            shiftDownBig(array,i,size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(<span class="keyword">int</span> element)</span></span>&#123;</span><br><span class="line">        array[size++] = element;</span><br><span class="line">        shiftUpSmall(array,size-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> element = array[<span class="number">0</span>];</span><br><span class="line">        array[<span class="number">0</span>] = array[--size];</span><br><span class="line">        shiftDownSmall(array,size,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyPriorityQueue myPriorityQueue = <span class="keyword">new</span> MyPriorityQueue();</span><br><span class="line">        myPriorityQueue.offer(<span class="number">7</span>);</span><br><span class="line">        myPriorityQueue.offer(<span class="number">9</span>);</span><br><span class="line">        myPriorityQueue.offer(<span class="number">5</span>);</span><br><span class="line">        System.out.println(myPriorityQueue.poll());</span><br><span class="line">        myPriorityQueue.offer(<span class="number">3</span>);</span><br><span class="line">        myPriorityQueue.offer(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //java中的优先级队列(PriorityQueue默认是小堆，compareTo返回小的排前面)</span></span><br><span class="line"><span class="comment">//        PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        priorityQueue.add(7);</span></span><br><span class="line"><span class="comment">//        priorityQueue.add(9);</span></span><br><span class="line"><span class="comment">//        priorityQueue.add(5);</span></span><br><span class="line"><span class="comment">//        System.out.println(priorityQueue.poll());</span></span><br><span class="line"><span class="comment">//        System.out.println(priorityQueue.poll());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>有错误还望指出哈</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>代码实现</tag>
      </tags>
  </entry>
  <entry>
    <title>实现简单的栈</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%A0%88/</url>
    <content><![CDATA[<h2 id="利用LinkedList实现一个简单的栈"><a href="#利用LinkedList实现一个简单的栈" class="headerlink" title="利用LinkedList实现一个简单的栈"></a>利用LinkedList实现一个简单的栈</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        que.add(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;  <span class="comment">//出栈顶元素</span></span><br><span class="line">    <span class="comment">//将链表里的前n-1个元素转移到后方（移除再加就变到了后面）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; que.size()-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            que.add(que.remove());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> que.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;   <span class="comment">//这里和pop的区别就是保存栈顶元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; que.size()-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            que.add(que.remove());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = que.remove();</span><br><span class="line">        que.add(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(que.size() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>代码实现</tag>
      </tags>
  </entry>
  <entry>
    <title>两个栈实现队列</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="实现一个队列"><a href="#实现一个队列" class="headerlink" title="实现一个队列"></a>实现一个队列</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack1.isEmpty()&amp;&amp;stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">//表示没有元素可以出队列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>代码实现</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的建立，遍历</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%EF%BC%8C%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="建立二叉树的两种方式"><a href="#建立二叉树的两种方式" class="headerlink" title="建立二叉树的两种方式"></a>建立二叉树的两种方式</h2><h3 id="（1）根据前序遍历数组和后序遍历数组建立"><a href="#（1）根据前序遍历数组和后序遍历数组建立" class="headerlink" title="（1）根据前序遍历数组和后序遍历数组建立"></a>（1）根据前序遍历数组和后序遍历数组建立</h3><h3 id="（2）根据中序遍历数组和后序遍历数组建立"><a href="#（2）根据中序遍历数组和后序遍历数组建立" class="headerlink" title="（2）根据中序遍历数组和后序遍历数组建立"></a>（2）根据中序遍历数组和后序遍历数组建立</h3><h2 id="遍历这里实现了后序遍历和层序遍历，中序和前序只是list-add的位置发生了改变（这里是递归实现）"><a href="#遍历这里实现了后序遍历和层序遍历，中序和前序只是list-add的位置发生了改变（这里是递归实现）" class="headerlink" title="遍历这里实现了后序遍历和层序遍历，中序和前序只是list.add的位置发生了改变（这里是递归实现）"></a>遍历这里实现了后序遍历和层序遍历，中序和前序只是list.add的位置发生了改变（这里是递归实现）</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="这里list集合存储了遍历的集合元素"><a href="#这里list集合存储了遍历的集合元素" class="headerlink" title="这里list集合存储了遍历的集合元素"></a>这里list集合存储了遍历的集合元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"%c "</span>,<span class="keyword">this</span>.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照前序遍历数组和中序遍历数组构建二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">buildTree1</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rootValues = preorder[<span class="number">0</span>];</span><br><span class="line">        Node root = <span class="keyword">new</span> Node(rootValues);</span><br><span class="line">        <span class="keyword">int</span> leftCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(leftCount = <span class="number">0</span>;leftCount &lt; inorder.length;leftCount++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[leftCount] == rootValues)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] leftPreorder = Arrays.copyOfRange(preorder,<span class="number">1</span>,leftCount+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span>[] leftInorder = Arrays.copyOfRange(inorder,<span class="number">0</span>,leftCount);</span><br><span class="line">        root.left = buildTree(leftPreorder,leftInorder);</span><br><span class="line">        <span class="keyword">int</span>[] rightPreorder = Arrays.copyOfRange(preorder,leftCount+<span class="number">1</span>,preorder.length);</span><br><span class="line">        <span class="keyword">int</span>[] rightInorder = Arrays.copyOfRange(inorder,leftCount+<span class="number">1</span>,inorder.length);</span><br><span class="line">        root.right = buildTree1(rightPreorder,rightInorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据中序遍历和后序遍历创建二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rootValues = postorder[postorder.length-<span class="number">1</span>];</span><br><span class="line">        Node root = <span class="keyword">new</span> Node(rootValues);</span><br><span class="line">        <span class="keyword">int</span> leftCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(leftCount = <span class="number">0</span>;leftCount &lt; inorder.length;leftCount++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[leftCount] == rootValues)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计出了左子树的节点数后求出左子树中序遍历的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] leftInorder = Arrays.copyOfRange(inorder,<span class="number">0</span>,leftCount);</span><br><span class="line">        <span class="keyword">int</span>[] leftPostorder = Arrays.copyOfRange(postorder,<span class="number">0</span>,leftCount);</span><br><span class="line">        root.left = buildTree(leftInorder,leftPostorder);</span><br><span class="line">        <span class="comment">//建右子树</span></span><br><span class="line">        <span class="keyword">int</span>[] rightInorder = Arrays.copyOfRange(inorder,leftCount+<span class="number">1</span>,inorder.length);</span><br><span class="line">        <span class="keyword">int</span>[] rightPostorder = Arrays.copyOfRange(postorder,leftCount,inorder.length-<span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(rightInorder,rightPostorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    题目：</span></span><br><span class="line"><span class="comment">    给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</span></span><br><span class="line"><span class="comment">百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</span></span><br><span class="line"><span class="comment">例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree</span></span><br><span class="line"><span class="comment">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(Node root,Node t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root == t)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(search(root.left,t))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> search(root.right,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">lowestCommonAncestor</span><span class="params">(Node root, Node p, Node q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == root || q == root)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> pInleft = search(root.left,p);</span><br><span class="line">        <span class="keyword">boolean</span> qInleft = search(root.left,q);</span><br><span class="line">        <span class="keyword">if</span>(pInleft &amp;&amp; qInleft)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!pInleft &amp;&amp; !qInleft)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">postOrderTraversal</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        postOrderTraversal(root.left);</span><br><span class="line">        postOrderTraversal(root.right);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//二叉树的层序遍历（广度优先遍历） 利用队列实现</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Queue&lt;Node&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            que.offer(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">                Node front = que.poll();</span><br><span class="line">                System.out.println(front.val);</span><br><span class="line">                <span class="keyword">if</span>(front.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    que.offer(front.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(front.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    que.offer(front.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//汇总思想</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">postOrderTraversal2</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; left = postOrderTraversal2(root.left);</span><br><span class="line">        List&lt;Integer&gt; right = postOrderTraversal2(root.right);</span><br><span class="line">        result.addAll(left);</span><br><span class="line">        result.addAll(right);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相等</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(Node s,Node t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> &amp;&amp; t == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || t == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.val == t.val &amp;&amp; isSameTree(s.left,t.left) &amp;&amp; isSameTree(s.right,t.right))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//t是否是s的子树(s,t一定不为空树)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSubTree</span><span class="params">(Node s,Node t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isSameTree(s.left,t) || isSameTree(s.right,t) || isSameTree(s,t))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>代码实现</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的镜像</title>
    <url>/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h2 id="【牛客】求出二叉树的镜像"><a href="#【牛客】求出二叉树的镜像" class="headerlink" title="【牛客】求出二叉树的镜像"></a>【牛客】求出二叉树的镜像</h2><p>链接：<br><a href="https://www.nowcoder.com/questionTerminal/564f4c26aa584921bc75623e48ca3011" target="_blank" rel="noopener">原题出处</a><br>来源：牛客网</p>
<p>其实我是看了大佬的博客：<br><a href="https://blog.csdn.net/xiaoxingxing1744/article/details/82782461" target="_blank" rel="noopener">大佬解说</a></p>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<p><img data-src="https://img-blog.csdnimg.cn/20191125162229432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDE5NDYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>有两种实现方式：<br>递归：</p>
<p>想象一下，加入只有三个结点，根结点，左孩子，右孩子<br>那么就交换左右孩子。</p>
<p>出口条件：</p>
<blockquote>
<p>节点为空或者左右孩子都为空</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里和非递归的条件很类似，都是说了一件事，只要有一个不为空，我就要交换（空和非空也有左右对称嘛）</span></span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换</span></span><br><span class="line">    TreeNode temp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归左子树</span></span><br><span class="line">    <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        Mirror(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归右子树</span></span><br><span class="line">    <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>非递归：<br>递归其实就是栈的入栈出栈，我们可以利用栈的特性对结点进行操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        <span class="comment">//这个条件映衬了上面所说的话</span></span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>||node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeNode temp = node.left;</span><br><span class="line">            node.left = node.right;</span><br><span class="line">            node.right = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//其实递归就是栈的入栈出栈，所以代码很相似</span></span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客网练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树平衡检查</title>
    <url>/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B9%B3%E8%A1%A1%E6%A3%80%E6%9F%A5/</url>
    <content><![CDATA[<p>参考：<a href="https://blog.csdn.net/canmengmeng/article/details/83506289" target="_blank" rel="noopener">学习自该大佬</a></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现一个函数，检查二叉树是否平衡，平衡的定义如下，对于树中的任意一个结点，其两颗子树的高度差不超过1。</p>
<p>给定指向树根结点的指针TreeNode* root，请返回一个bool，代表这棵树是否平衡。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>1.求出左子树与右子树的高度差，大于1则false<br>2.如何求？<br>递归求出，如果节点为空那么则深度为0，这同时也是递归出口，若不为空则递归左子树与右子树。<br>注意：最终二叉树的高度是左右子树取高度高的加1</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Balance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalance</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = getTreeHeight(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = getTreeHeight(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.abs(left - right) &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTreeHeight</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里为什么加1?，因为root为null时返回的是0，我们假设只有三个节点的完全二叉树</span></span><br><span class="line">        <span class="comment">//那是不是最后的结果就是根节点的左孩子0+0+1，根节点的右孩子0+0+1,最后1和1取大的再加1，不就是2嘛</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(getTreeHeight(root.left),getTreeHeight(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>牛客网练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>链表分割</title>
    <url>/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0/%E9%93%BE%E8%A1%A8%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<p>链接：<br><a href="https://www.nowcoder.com/questionTerminal/0e27e0b064de4eacac178676ef9c9d70?mutiTagIds=639&orderByHotValue=1&questionTypes=000100&commentTags=Python" target="_blank" rel="noopener">原题出处</a><br>来源：牛客网</p>
<p>[编程题] 链表分割<br>热度指数：43019时间限制：3秒空间限制：32768K<br>算法知识视频讲解</p>
<p>编写代码，以给定值x为基准将链表分割成两部分，所有小于x的结点排在大于或等于x的结点之前</p>
<p>给定一个链表的头指针 ListNode* pHead，请返回重新排列后的链表的头指针。注意：分割以后保持原来的数据顺序不变。</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>一看到这道题我就想到了创建两个链表的想法，一个链表放小于指定x的所有节点，另一个放大于等于的，最后将两个链表合二为一不就是要求的结果吗</p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>（1）记住两个链表的头节点，在拼接时需要用到<br>（2）考虑空异常</p>
<p><strong><em>未实现的思路：</em></strong><br>既然可以这样弄两个链表，那么为什么不这样（创建一个链表就可以）呢？</p>
<p>将小于x的节点头插到该链表，大于等于的尾插到该链表，最后形成的链表不就是答案吗。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>我实现的是两个链表的（可以优化的地方：将尾插算法抽取出来为一个方法）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode pHead, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// write code here</span></span><br><span class="line">     ListNode left = <span class="keyword">null</span>;</span><br><span class="line">     ListNode right = <span class="keyword">null</span>;</span><br><span class="line">     ListNode p1 = <span class="keyword">null</span>;</span><br><span class="line">     ListNode p2 = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">while</span>(pHead!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">if</span>(pHead.val&lt;x)&#123;</span><br><span class="line">             <span class="keyword">if</span>(left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                 left = <span class="keyword">new</span> ListNode(pHead.val);</span><br><span class="line">                 p1 = left; <span class="comment">//左链表的头节点</span></span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 left.next = <span class="keyword">new</span> ListNode(pHead.val);</span><br><span class="line">                 left = left.next;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">if</span>(right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                 right = <span class="keyword">new</span> ListNode(pHead.val);</span><br><span class="line">                 p2 = right;    <span class="comment">//右链表的头节点</span></span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 right.next = <span class="keyword">new</span> ListNode(pHead.val);</span><br><span class="line">                 right = right.next;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         pHead = pHead.next;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(p1==<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> p2;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(p2==<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> p1;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//走到这里说明都不为空，需要连接</span></span><br><span class="line">     <span class="comment">//找到左链表的最后一个节点将其与右链表连接</span></span><br><span class="line">     ListNode cur = p1;</span><br><span class="line">     <span class="keyword">while</span>(cur.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         cur = cur.next;</span><br><span class="line">     &#125;</span><br><span class="line">     cur.next = p2;</span><br><span class="line">     <span class="keyword">return</span> p1;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<p>如果有错误还望指出！</p>
]]></content>
      <categories>
        <category>牛客网练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>统计同成绩人数</title>
    <url>/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0/%E7%BB%9F%E8%AE%A1%E5%90%8C%E6%88%90%E7%BB%A9%E4%BA%BA%E6%95%B0/</url>
    <content><![CDATA[<p>链接：<br><a href="https://www.nowcoder.com/questionTerminal/987123efea5f43709f31ad79a318ca69" target="_blank" rel="noopener">原题出处</a><br>来源：牛客网</p>
<p>读入N名学生的成绩，将获得某一给定分数的学生人数输出。</p>
<p>输入描述:<br>测试输入包含若干测试用例，每个测试用例的格式为</p>
<blockquote>
<p>第1行：N<br>第2行：N名学生的成绩，相邻两数字用一个空格间隔。<br>第3行：给定分数</p>
</blockquote>
<p>当读到N=0时输入结束。其中N不超过1000，成绩分数为（包含）0到100之间的一个整数。</p>
<p>输出描述:<br>对每个测试用例，将获得给定分数的学生人数输出。<br>示例1<br>输入</p>
<blockquote>
<p>3<br>80 60 90<br>60<br>2<br>85 66<br>0<br>5<br>60 75 90 55 75<br>75<br>0</p>
</blockquote>
<p>输出</p>
<blockquote>
<p>1<br>0<br>2</p>
</blockquote>
<p>一开始，我写了一个封装类来封装信息，并将该类添加到集合中。这样才可以保证输出0结束后记住输入的所有数据。<br>在idea上复制输入示例代码测试，输出的数据与输出示例一样但是通不过测试，后来查了一下网络上的，他们是按一组一组数据处理的不是将所有数据输入后在统一处理，但是这样将输入示例在idea上测试与输出示例不符但又可以通过。百思不得其解，无情！<br>这里先附上可以通过的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> N=in.nextInt();</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        in.nextLine();  <span class="comment">//吃个空格,nextLine()和next()以及nextInt()一起用一定要格外注意空格回车</span></span><br><span class="line">        String scores = in.nextLine();</span><br><span class="line">        <span class="keyword">int</span> score = in.nextInt();</span><br><span class="line"></span><br><span class="line">        String[] s=scores.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(String t:s)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = Integer.parseInt(t);</span><br><span class="line">            <span class="keyword">if</span>(i==score)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>下面的是封装的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Day16</span></span>&#123;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> N,String scores,<span class="keyword">int</span> theScore)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        String[] s = scores.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> score = Integer.parseInt(s[i]);</span><br><span class="line">            <span class="keyword">if</span>(theScore==score)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        String scores;</span><br><span class="line">        <span class="keyword">int</span> theScore;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> N,String scores,<span class="keyword">int</span> theScore)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.N=N;</span><br><span class="line">            <span class="keyword">this</span>.scores = scores;</span><br><span class="line">            <span class="keyword">this</span>.theScore = theScore;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCount</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.count = count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        List&lt;Test&gt; list = <span class="keyword">new</span> ArrayList&lt;Test&gt;();</span><br><span class="line">        <span class="keyword">int</span> N=in.nextInt();</span><br><span class="line">        in.nextLine();  <span class="comment">//吃空格</span></span><br><span class="line">        <span class="keyword">while</span>(N!=<span class="number">0</span>)&#123;</span><br><span class="line">            String scores=in.nextLine();<span class="comment">/*</span></span><br><span class="line"><span class="comment">            System.out.println(scores);*/</span></span><br><span class="line">            <span class="keyword">int</span> theScore = in.nextInt();</span><br><span class="line">            list.add(<span class="keyword">new</span> Test(N,scores,theScore));</span><br><span class="line">            N = in.nextInt();</span><br><span class="line">            in.nextLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">            Test test = list.get(i);</span><br><span class="line">            <span class="keyword">int</span> count = fun(test.N,test.scores,test.theScore);</span><br><span class="line">            test.setCount(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            System.out.println(list.get(i).count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如有错误还望指出哈！</p>
]]></content>
      <categories>
        <category>牛客网练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>尼科彻斯定理</title>
    <url>/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0/%E5%B0%BC%E7%A7%91%E5%BD%BB%E6%96%AF%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>链接：<br><a href="https://www.nowcoder.com/questionTerminal/dbace3a5b3c4480e86ee3277f3fe1e85?toCommentId=732952" target="_blank" rel="noopener">原题出处</a><br>来源：牛客网</p>
<p>验证尼科彻斯定理，即：任何一个整数m的立方都可以写成m个连续奇数之和。</p>
<p>例如：</p>
<p>1^3=1 </p>
<p>2^3=3+5 </p>
<p>3^3=7+9+11 </p>
<p>4^3=13+15+17+19 </p>
<blockquote>
<p>接口说明<br>原型：<br> /*<br> 功能: 验证尼科彻斯定理，即：任何一个整数m的立方都可以写成m个连续奇数之和。<br> 原型：<br>     int GetSequeOddNum(int m,char * pcSequeOddNum);<br> 输入参数：<br>     int m：整数(取值范围：1～100)<br> 返回值：<br>     m个连续奇数(格式：“7+9+11”);<br> <em>/<br> public String GetSequeOddNum(int m)<br> {<br>     /*在这里实现功能</em>/<br>     return null;<br> }</p>
</blockquote>
<p>输入描述:</p>
<blockquote>
<p>输入一个int整数</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>输出分解后的string</p>
</blockquote>
<p>示例1<br>输入</p>
<blockquote>
<p>6</p>
</blockquote>
<p>输出</p>
<blockquote>
<p>31+33+35+37+39+41</p>
</blockquote>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>仔细观察发现，其实<br>2^3=3+5<br>3^3=7+9+11</p>
<p>3和5怎么来的？<br>其实就是2^2左右两个奇数<br>7,9,11是3^2  以及 3^2两边的奇数</p>
<p>以此类推，对于4和5也是一样的<br>只是对于偶数来说，不要自己的平方，奇数需要自己的平方，然后在加上自己数平方的左右两边的奇数，什么时候奇数够了就停止，比如3^ 3需要3个奇数，那么就是3^2 以及 3^两边的两个奇数，左边一个右边一个！<br>如果是5则需要5^2以及其左边两个和右边两个的奇数一共5个</p>
<p>下面是代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">//发现数学规律哎虚浮</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">GetSequeOddNum</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="keyword">if</span>((m*m)%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m-<span class="number">1</span>;count++)&#123;</span><br><span class="line">                result[i++]=m*m-<span class="number">2</span>*count;</span><br><span class="line">                result[i++]=m*m+<span class="number">2</span>*count;</span><br><span class="line">            &#125;</span><br><span class="line">            result[m-<span class="number">1</span>]=m*m;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;count++)&#123;</span><br><span class="line">                result[i++]=(m*m-<span class="number">1</span>)-<span class="number">2</span>*count;</span><br><span class="line">                result[i++]=(m*m+<span class="number">1</span>)+<span class="number">2</span>*count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(result);</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; result.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==result.length-<span class="number">1</span>)&#123;</span><br><span class="line">                sb.append(result[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(result[i]).append(<span class="string">"+"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(in.hasNext())&#123;</span><br><span class="line">            <span class="keyword">int</span> m = in.nextInt();</span><br><span class="line">            System.out.println(GetSequeOddNum(m));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客网练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>机器人走方格I</title>
    <url>/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B5%B0%E6%96%B9%E6%A0%BCI/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>链接：<br><a href="https://www.nowcoder.com/questionTerminal/e8bb8e68434e42acbcdff0341f2a32c5" target="_blank" rel="noopener">原题</a><br>来源：牛客网</p>
<p>有一个XxY的网格，一个机器人只能走格点且只能向右或向下走，要从左上角走到右下角。请设计一个算法，计算机器人有多少种走法。<br>给定两个正整数int x,int y，请返回机器人的走法数目。保证x＋y小于等于12。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//机器人</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>||y==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//count(x-1,y)代表向下走一步后所有的情况，count(x,y-1)代表向右走一步后的所有情况</span></span><br><span class="line">    <span class="keyword">return</span> count(x-<span class="number">1</span>,y)+count(x,y-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>机器人每走一步都有两种走法，要么走右面，要么有下面。<br>如果走右面，那么矩阵（网格）就缩小为X<em>(Y-1)<br>如果走下面，那么矩阵（网格）就缩小为(X-1)</em>Y</p>
<p>试想一直走下去，当矩阵只有一行或一列的时候，机器人就只有一种走法。（是不是很想递归出口呢）</p>
<p>矩阵的缩小是问题化简<br>递归出口是矩阵为一行或一列</p>
<p>那么我们就可以假设机器人的第一步分为两种情况<br>（1）向下走一步，矩阵缩小为(X-1) * Y<br>（2）向右走一步，矩阵缩小为X * (Y-1)</p>
<p>我们只考虑机器人的第一步，将这两种情况的走法相加起来就是机器人的所有走法，因为随着递归，矩阵最终会变为一列或一行，返走回数值1供上层计算，最终递归出来的就是走法数！</p>
<p><strong>如果有错误请提醒我呀</strong></p>
]]></content>
      <categories>
        <category>牛客网练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>不用+号等算数运算符实现加法</title>
    <url>/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%BB%83%E4%B9%A0/%E4%B8%8D%E7%94%A8+%E5%8F%B7%E7%AD%89%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E7%8E%B0%E5%8A%A0%E6%B3%95/</url>
    <content><![CDATA[<p>转自：<br><a href="https://www.iteye.com/blog/brokendreams-2084088" target="_blank" rel="noopener">不用加减符号实现加减法</a></p>
<p>今天有群友发了一个问题，要求不用加减符号(包括负号)来实现加减法。</p>
<h2 id="分析一下"><a href="#分析一下" class="headerlink" title="分析一下"></a>分析一下</h2><p>先看最简单的情况，假设1+1，按二进制算的话结果是10，可以看到从右往左的第一位变为0，第二位由于进位变为1。<br>        第1位的值有4种，0+0=0、1+0=1、0+1=1、1+1=0，这正好符合“异或”的情况。<br>        第2位的值来自于第一位的进位加上本身的值，进位的情况也有4种，0+0=0、1+0=0、0+1=0,1+1=1，这正好符合“与”的情况。<br>        考虑一般性，a+b就等同于a^b + (a&amp;b) &lt;&lt; 1，而这又是一个加法，可递归求解，出口就是当进位为0的时候。</p>
<h2 id="看个例子："><a href="#看个例子：" class="headerlink" title="看个例子："></a>看个例子：</h2><p>11+2<br>转为二进制，套用上面公式分析：<br> 1011 + 0010<br>=1001 + 0100<br>=1101 + 0000<br>=1101<br>结果转为10进制为13  </p>
<pre><code>可以自己在草稿纸上多看看例子观察下。

所以Java代码实现如下：</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : add(a ^ b ,(a &amp; b) &lt;&lt; <span class="number">1</span>);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>   那么减法怎么搞呢？减法也能用加法表示嘛，比如a-b就等于a+(-b)，但不能出现负号，我们知道Java中整型数值编码方式为补码，所以一个数对应的负数就这个数“取反加1”，so 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> add(a, add(~b, <span class="number">1</span>));  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<pre><code>这是群友给的答案，有点意思，记录一下。</code></pre>]]></content>
      <categories>
        <category>牛客网练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇文章</title>
    <url>/%E6%B5%8B%E8%AF%95/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>今天满怀激动尝试自己搞一个小博客！！！大年初一希望可以成功撒！</p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>心情</tag>
      </tags>
  </entry>
</search>
